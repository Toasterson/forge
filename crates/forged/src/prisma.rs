// Code generated by Prisma Client Rust. DO NOT EDIT

pub static DATAMODEL_STR: &'static str =
    include_str!("/export/home/toast/workspace/illumos/forge/crates/forged/prisma/schema.prisma");
static DATABASE_STR: &'static str = "postgres";
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(
    url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder()
        .with_url(url.to_string())
        .build()
        .await
}
pub mod domain {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "Domain";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod dns_name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "dnsName";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDnsName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::DnsName(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::DnsName(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::DnsNameEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            DnsName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::DnsName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::DnsName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod authconf {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "authconf";
        pub struct Set(pub ::prisma_client_rust::serde_json::Value);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetAuthconf(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Authconf(v)
            }
        }
        pub fn set<T: From<Set>>(value: ::prisma_client_rust::serde_json::Value) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Authconf(direction)
        }
        pub fn equals(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Authconf(_prisma::read_filters::JsonFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::JsonFilter,
            Authconf,
            {
                fn path(_: Vec<String>) -> Path;
                fn string_contains(_: String) -> StringContains;
                fn string_starts_with(_: String) -> StringStartsWith;
                fn string_ends_with(_: String) -> StringEndsWith;
                fn array_contains(
                    _: Option<::prisma_client_rust::serde_json::Value>,
                ) -> ArrayContains;
                fn array_starts_with(
                    _: Option<::prisma_client_rust::serde_json::Value>,
                ) -> ArrayStartsWith;
                fn array_ends_with(
                    _: Option<::prisma_client_rust::serde_json::Value>,
                ) -> ArrayEndsWith;
                fn lt(_: ::prisma_client_rust::serde_json::Value) -> Lt;
                fn lte(_: ::prisma_client_rust::serde_json::Value) -> Lte;
                fn gt(_: ::prisma_client_rust::serde_json::Value) -> Gt;
                fn gte(_: ::prisma_client_rust::serde_json::Value) -> Gte;
                fn not(_: ::prisma_client_rust::serde_json::Value) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Authconf(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Authconf(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod actors {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "actors";
        pub struct Fetch(pub actor::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<actor::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: actor::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: actor::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Actors(v)
            }
        }
        pub fn fetch(params: Vec<actor::WhereParam>) -> Fetch {
            Fetch(actor::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<actor::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectActors(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<actor::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<actor::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectActors(params)
        }
        pub fn set(params: Vec<actor::UniqueWhereParam>) -> SetParam {
            SetParam::SetActors(params)
        }
        pub fn some(value: Vec<actor::WhereParam>) -> WhereParam {
            WhereParam::ActorsSome(value)
        }
        pub fn every(value: Vec<actor::WhereParam>) -> WhereParam {
            WhereParam::ActorsEvery(value)
        }
        pub fn none(value: Vec<actor::WhereParam>) -> WhereParam {
            WhereParam::ActorsNone(value)
        }
        pub enum Include {
            Select(actor::ManyArgs, Vec<actor::SelectParam>),
            Include(actor::ManyArgs, Vec<actor::IncludeParam>),
            Fetch(actor::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Actors(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <actor::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <actor::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: actor::ManyArgs,
                nested_selections: Vec<actor::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: actor::ManyArgs,
                nested_selections: Vec<actor::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(actor::ManyArgs, Vec<actor::SelectParam>),
            Include(actor::ManyArgs, Vec<actor::IncludeParam>),
            Fetch(actor::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Actors(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <actor::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: actor::ManyArgs,
                nested_selections: Vec<actor::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: actor::ManyArgs,
                nested_selections: Vec<actor::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(
        dns_name: String,
        authconf: ::prisma_client_rust::serde_json::Value,
        _params: Vec<SetParam>,
    ) -> (
        String,
        ::prisma_client_rust::serde_json::Value,
        Vec<SetParam>,
    ) {
        (dns_name, authconf, _params)
    }
    pub fn create_unchecked(
        dns_name: String,
        authconf: ::prisma_client_rust::serde_json::Value,
        _params: Vec<SetParam>,
    ) -> (
        String,
        ::prisma_client_rust::serde_json::Value,
        Vec<SetParam>,
    ) {
        (dns_name, authconf, _params)
    }
    #[macro_export]
    macro_rules ! _select_domain { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: domain :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: domain :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: domain :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: domain :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: domain :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: domain :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , dns_name , authconf , actors } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: domain :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: domain :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: domain :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: domain :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: domain :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: domain :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "dnsName" , "authconf" , "actors"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: domain :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; dns_name) => { String } ; (@ field_type ; authconf) => { :: prisma_client_rust :: serde_json :: Value } ; (@ field_type ; actors : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < actors :: Data > } ; (@ field_type ; actors) => { Vec < crate :: prisma :: actor :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Domain" , available relations are "id, dns_name, authconf, actors")) } ; (@ field_module ; actors : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: actor :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: domain :: SelectParam > :: into (crate :: prisma :: domain :: id :: Select) } ; (@ selection_field_to_selection_param ; dns_name) => { Into :: < crate :: prisma :: domain :: SelectParam > :: into (crate :: prisma :: domain :: dns_name :: Select) } ; (@ selection_field_to_selection_param ; authconf) => { Into :: < crate :: prisma :: domain :: SelectParam > :: into (crate :: prisma :: domain :: authconf :: Select) } ; (@ selection_field_to_selection_param ; actors $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: domain :: SelectParam > :: into (crate :: prisma :: domain :: actors :: Select :: $ selection_mode (crate :: prisma :: actor :: ManyArgs :: new (crate :: prisma :: actor :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: actor :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; actors $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: domain :: SelectParam > :: into (crate :: prisma :: domain :: actors :: Select :: Fetch (crate :: prisma :: actor :: ManyArgs :: new (crate :: prisma :: actor :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: domain :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; dns_name) => { "dnsName" } ; (@ field_serde_name ; authconf) => { "authconf" } ; (@ field_serde_name ; actors) => { "actors" } ; }
    pub use _select_domain as select;
    pub enum SelectParam {
        Id(id::Select),
        DnsName(dns_name::Select),
        Authconf(authconf::Select),
        Actors(actors::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::DnsName(data) => data.to_selection(),
                Self::Authconf(data) => data.to_selection(),
                Self::Actors(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_domain { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: domain :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: domain :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: domain :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: domain :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: domain :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: domain :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: domain :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: domain :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { actors } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub dns_name : String , pub authconf : :: prisma_client_rust :: serde_json :: Value , $ (pub $ field : crate :: prisma :: domain :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (dns_name) , stringify ! (authconf)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: domain :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: domain :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: domain :: dns_name :: NAME , & self . dns_name) ? ; state . serialize_field (crate :: prisma :: domain :: authconf :: NAME , & self . authconf) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , dns_name , authconf } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: domain :: $ field :: NAME) , + , crate :: prisma :: domain :: id :: NAME , crate :: prisma :: domain :: dns_name :: NAME , crate :: prisma :: domain :: authconf :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: domain :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: domain :: id :: NAME => Ok (Field :: id) , crate :: prisma :: domain :: dns_name :: NAME => Ok (Field :: dns_name) , crate :: prisma :: domain :: authconf :: NAME => Ok (Field :: authconf) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut dns_name = None ; let mut authconf = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: domain :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: dns_name => { if dns_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: domain :: dns_name :: NAME)) ; } dns_name = Some (map . next_value () ?) ; } Field :: authconf => { if authconf . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: domain :: authconf :: NAME)) ; } authconf = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: domain :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: domain :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: domain :: id :: NAME)) ? ; let dns_name = dns_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: domain :: dns_name :: NAME)) ? ; let authconf = authconf . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: domain :: authconf :: NAME)) ? ; Ok (Data { id , dns_name , authconf , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "dnsName" , "authconf" , "actors"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: domain :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; actors : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < actors :: Data > } ; (@ field_type ; actors) => { Vec < crate :: prisma :: actor :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Domain" , available relations are "actors")) } ; (@ field_module ; actors : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: actor :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; actors $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: domain :: IncludeParam > :: into (crate :: prisma :: domain :: actors :: Include :: $ selection_mode (crate :: prisma :: actor :: ManyArgs :: new (crate :: prisma :: actor :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: actor :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; actors $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: domain :: IncludeParam > :: into (crate :: prisma :: domain :: actors :: Include :: Fetch (crate :: prisma :: actor :: ManyArgs :: new (crate :: prisma :: actor :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: domain :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; dns_name) => { "dnsName" } ; (@ field_serde_name ; authconf) => { "authconf" } ; (@ field_serde_name ; actors) => { "actors" } ; }
    pub use _include_domain as include;
    pub enum IncludeParam {
        Id(id::Include),
        DnsName(dns_name::Include),
        Authconf(authconf::Include),
        Actors(actors::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::DnsName(data) => data.to_selection(),
                Self::Authconf(data) => data.to_selection(),
                Self::Actors(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_domain { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: domain struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "dnsName")] pub dns_name : String , # [serde (rename = "authconf")] pub authconf : :: prisma_client_rust :: serde_json :: Value } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_domain as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "dnsName")]
        pub dns_name: String,
        #[serde(rename = "authconf")]
        pub authconf: ::prisma_client_rust::serde_json::Value,
        #[serde(rename = "actors")]
        pub actors: Option<Vec<super::actor::Data>>,
    }
    impl Data {
        pub fn actors(
            &self,
        ) -> Result<&Vec<super::actor::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.actors
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(actors),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Actors(super::actor::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Actors(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: actor :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        actors::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetDnsName(String),
        SetAuthconf(::prisma_client_rust::serde_json::Value),
        ConnectActors(Vec<super::actor::UniqueWhereParam>),
        DisconnectActors(Vec<super::actor::UniqueWhereParam>),
        SetActors(Vec<super::actor::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetDnsName(value) => (
                    dns_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetAuthconf(value) => (
                    authconf::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Json(
                        ::prisma_client_rust::serde_json::to_string(&value).unwrap(),
                    ),
                ),
                SetParam::ConnectActors(where_params) => (
                    actors::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::actor::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectActors(where_params) => (
                    actors::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::actor::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetActors(where_params) => (
                    actors::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::actor::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(String),
        DnsName(String),
        Authconf(::prisma_client_rust::serde_json::Value),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::DnsName(value) => Self::SetDnsName(value),
                UncheckedSetParam::Authconf(value) => Self::SetAuthconf(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        DnsName(::prisma_client_rust::Direction),
        Authconf(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::DnsName(direction) => (
                    dns_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Authconf(direction) => (
                    authconf::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        DnsName(_prisma::read_filters::StringFilter),
        Authconf(_prisma::read_filters::JsonFilter),
        ActorsSome(Vec<super::actor::WhereParam>),
        ActorsEvery(Vec<super::actor::WhereParam>),
        ActorsNone(Vec<super::actor::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::DnsName(value) => (dns_name::NAME, value.into()),
                Self::Authconf(value) => (authconf::NAME, value.into()),
                Self::ActorsSome(where_params) => (
                    actors::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ActorsEvery(where_params) => (
                    actors::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ActorsNone(where_params) => (
                    actors::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        DnsNameEquals(String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::DnsNameEquals(value) => {
                    Self::DnsName(_prisma::read_filters::StringFilter::Equals(value))
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(dns_name::NAME),
                ::prisma_client_rust::sel(authconf::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            dns_name: String,
            authconf: ::prisma_client_rust::serde_json::Value,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([dns_name::set(dns_name), authconf::set(authconf)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            dns_name: String,
            authconf: ::prisma_client_rust::serde_json::Value,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([dns_name::set(dns_name), authconf::set(authconf)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(
                String,
                ::prisma_client_rust::serde_json::Value,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(dns_name, authconf, mut _params)| {
                    _params.extend([dns_name::set(dns_name), authconf::set(authconf)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (dns_name, authconf, mut _params): (
                String,
                ::prisma_client_rust::serde_json::Value,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([dns_name::set(dns_name), authconf::set(authconf)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod actor {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "Actor";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod display_name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "displayName";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDisplayName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::DisplayName(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::DisplayName(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::DisplayName(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            DisplayName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::DisplayName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::DisplayName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod handle {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "handle";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetHandle(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Handle(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Handle(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::HandleEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Handle,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Handle(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Handle(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod domain {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "domain";
        pub struct Fetch(pub domain::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<domain::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Domain(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(domain::UniqueArgs::new())
        }
        pub struct Connect(domain::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectDomain(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: domain::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<domain::WhereParam>) -> WhereParam {
            WhereParam::DomainIs(value)
        }
        pub fn is_not(value: Vec<domain::WhereParam>) -> WhereParam {
            WhereParam::DomainIsNot(value)
        }
        pub enum Include {
            Select(Vec<domain::SelectParam>),
            Include(Vec<domain::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Domain(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <domain::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <domain::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("domain", None, [], selections)
            }
            pub fn select(nested_selections: Vec<domain::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<domain::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<domain::SelectParam>),
            Include(Vec<domain::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Domain(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <domain::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("domain", None, [], selections)
            }
            pub fn select(nested_selections: Vec<domain::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<domain::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod domain_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "domainId";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDomainId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::DomainId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::DomainId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::DomainId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            DomainId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::DomainId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::DomainId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod key {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "Key";
        pub struct Fetch(pub key::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<key::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: key::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: key::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Key(v)
            }
        }
        pub fn fetch(params: Vec<key::WhereParam>) -> Fetch {
            Fetch(key::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<key::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectKey(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<key::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<key::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectKey(params)
        }
        pub fn set(params: Vec<key::UniqueWhereParam>) -> SetParam {
            SetParam::SetKey(params)
        }
        pub fn some(value: Vec<key::WhereParam>) -> WhereParam {
            WhereParam::KeySome(value)
        }
        pub fn every(value: Vec<key::WhereParam>) -> WhereParam {
            WhereParam::KeyEvery(value)
        }
        pub fn none(value: Vec<key::WhereParam>) -> WhereParam {
            WhereParam::KeyNone(value)
        }
        pub enum Include {
            Select(key::ManyArgs, Vec<key::SelectParam>),
            Include(key::ManyArgs, Vec<key::IncludeParam>),
            Fetch(key::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Key(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <key::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <key::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(args: key::ManyArgs, nested_selections: Vec<key::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(args: key::ManyArgs, nested_selections: Vec<key::IncludeParam>) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(key::ManyArgs, Vec<key::SelectParam>),
            Include(key::ManyArgs, Vec<key::IncludeParam>),
            Fetch(key::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Key(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <key::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(args: key::ManyArgs, nested_selections: Vec<key::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(args: key::ManyArgs, nested_selections: Vec<key::IncludeParam>) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(
        display_name: String,
        handle: String,
        domain: super::domain::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        super::domain::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (display_name, handle, domain, _params)
    }
    pub fn create_unchecked(
        display_name: String,
        handle: String,
        domain_id: String,
        _params: Vec<SetParam>,
    ) -> (String, String, String, Vec<SetParam>) {
        (display_name, handle, domain_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_actor { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: actor :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: actor :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: actor :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: actor :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: actor :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: actor :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , display_name , handle , domain , domain_id , key } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: actor :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: actor :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: actor :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: actor :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: actor :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: actor :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "displayName" , "handle" , "domain" , "domainId" , "Key"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: actor :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; display_name) => { String } ; (@ field_type ; handle) => { String } ; (@ field_type ; domain : $ selection_mode : ident { $ ($ selections : tt) + }) => { domain :: Data } ; (@ field_type ; domain) => { crate :: prisma :: domain :: Data } ; (@ field_type ; domain_id) => { String } ; (@ field_type ; key : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < key :: Data > } ; (@ field_type ; key) => { Vec < crate :: prisma :: key :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Actor" , available relations are "id, display_name, handle, domain, domain_id, key")) } ; (@ field_module ; domain : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: domain :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; key : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: key :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: actor :: SelectParam > :: into (crate :: prisma :: actor :: id :: Select) } ; (@ selection_field_to_selection_param ; display_name) => { Into :: < crate :: prisma :: actor :: SelectParam > :: into (crate :: prisma :: actor :: display_name :: Select) } ; (@ selection_field_to_selection_param ; handle) => { Into :: < crate :: prisma :: actor :: SelectParam > :: into (crate :: prisma :: actor :: handle :: Select) } ; (@ selection_field_to_selection_param ; domain $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: actor :: SelectParam > :: into (crate :: prisma :: actor :: domain :: Select :: $ selection_mode (crate :: prisma :: domain :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; domain $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: actor :: SelectParam > :: into (crate :: prisma :: actor :: domain :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; domain_id) => { Into :: < crate :: prisma :: actor :: SelectParam > :: into (crate :: prisma :: actor :: domain_id :: Select) } ; (@ selection_field_to_selection_param ; key $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: actor :: SelectParam > :: into (crate :: prisma :: actor :: key :: Select :: $ selection_mode (crate :: prisma :: key :: ManyArgs :: new (crate :: prisma :: key :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: key :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; key $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: actor :: SelectParam > :: into (crate :: prisma :: actor :: key :: Select :: Fetch (crate :: prisma :: key :: ManyArgs :: new (crate :: prisma :: key :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: actor :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; display_name) => { "displayName" } ; (@ field_serde_name ; handle) => { "handle" } ; (@ field_serde_name ; domain) => { "domain" } ; (@ field_serde_name ; domain_id) => { "domainId" } ; (@ field_serde_name ; key) => { "Key" } ; }
    pub use _select_actor as select;
    pub enum SelectParam {
        Id(id::Select),
        DisplayName(display_name::Select),
        Handle(handle::Select),
        Domain(domain::Select),
        DomainId(domain_id::Select),
        Key(key::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::DisplayName(data) => data.to_selection(),
                Self::Handle(data) => data.to_selection(),
                Self::Domain(data) => data.to_selection(),
                Self::DomainId(data) => data.to_selection(),
                Self::Key(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_actor { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: actor :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: actor :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: actor :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: actor :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: actor :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: actor :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: actor :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: actor :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { domain , key } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub display_name : String , pub handle : String , pub domain_id : String , $ (pub $ field : crate :: prisma :: actor :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (display_name) , stringify ! (handle) , stringify ! (domain_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: actor :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: actor :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: actor :: display_name :: NAME , & self . display_name) ? ; state . serialize_field (crate :: prisma :: actor :: handle :: NAME , & self . handle) ? ; state . serialize_field (crate :: prisma :: actor :: domain_id :: NAME , & self . domain_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , display_name , handle , domain_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: actor :: $ field :: NAME) , + , crate :: prisma :: actor :: id :: NAME , crate :: prisma :: actor :: display_name :: NAME , crate :: prisma :: actor :: handle :: NAME , crate :: prisma :: actor :: domain_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: actor :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: actor :: id :: NAME => Ok (Field :: id) , crate :: prisma :: actor :: display_name :: NAME => Ok (Field :: display_name) , crate :: prisma :: actor :: handle :: NAME => Ok (Field :: handle) , crate :: prisma :: actor :: domain_id :: NAME => Ok (Field :: domain_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut display_name = None ; let mut handle = None ; let mut domain_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: actor :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: display_name => { if display_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: actor :: display_name :: NAME)) ; } display_name = Some (map . next_value () ?) ; } Field :: handle => { if handle . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: actor :: handle :: NAME)) ; } handle = Some (map . next_value () ?) ; } Field :: domain_id => { if domain_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: actor :: domain_id :: NAME)) ; } domain_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: actor :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: actor :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: actor :: id :: NAME)) ? ; let display_name = display_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: actor :: display_name :: NAME)) ? ; let handle = handle . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: actor :: handle :: NAME)) ? ; let domain_id = domain_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: actor :: domain_id :: NAME)) ? ; Ok (Data { id , display_name , handle , domain_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "displayName" , "handle" , "domain" , "domainId" , "Key"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: actor :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; domain : $ selection_mode : ident { $ ($ selections : tt) + }) => { domain :: Data } ; (@ field_type ; domain) => { crate :: prisma :: domain :: Data } ; (@ field_type ; key : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < key :: Data > } ; (@ field_type ; key) => { Vec < crate :: prisma :: key :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Actor" , available relations are "domain, key")) } ; (@ field_module ; domain : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: domain :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; key : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: key :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; domain $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: actor :: IncludeParam > :: into (crate :: prisma :: actor :: domain :: Include :: $ selection_mode (crate :: prisma :: domain :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; domain $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: actor :: IncludeParam > :: into (crate :: prisma :: actor :: domain :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; key $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: actor :: IncludeParam > :: into (crate :: prisma :: actor :: key :: Include :: $ selection_mode (crate :: prisma :: key :: ManyArgs :: new (crate :: prisma :: key :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: key :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; key $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: actor :: IncludeParam > :: into (crate :: prisma :: actor :: key :: Include :: Fetch (crate :: prisma :: key :: ManyArgs :: new (crate :: prisma :: key :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: actor :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; display_name) => { "displayName" } ; (@ field_serde_name ; handle) => { "handle" } ; (@ field_serde_name ; domain) => { "domain" } ; (@ field_serde_name ; domain_id) => { "domainId" } ; (@ field_serde_name ; key) => { "Key" } ; }
    pub use _include_actor as include;
    pub enum IncludeParam {
        Id(id::Include),
        DisplayName(display_name::Include),
        Handle(handle::Include),
        Domain(domain::Include),
        DomainId(domain_id::Include),
        Key(key::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::DisplayName(data) => data.to_selection(),
                Self::Handle(data) => data.to_selection(),
                Self::Domain(data) => data.to_selection(),
                Self::DomainId(data) => data.to_selection(),
                Self::Key(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_actor { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: actor struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "displayName")] pub display_name : String , # [serde (rename = "handle")] pub handle : String , # [serde (rename = "domainId")] pub domain_id : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_actor as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "displayName")]
        pub display_name: String,
        #[serde(rename = "handle")]
        pub handle: String,
        #[serde(rename = "domain")]
        pub domain: Option<Box<super::domain::Data>>,
        #[serde(rename = "domainId")]
        pub domain_id: String,
        #[serde(rename = "Key")]
        pub key: Option<Vec<super::key::Data>>,
    }
    impl Data {
        pub fn domain(
            &self,
        ) -> Result<&super::domain::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.domain
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(domain),
                ))
                .map(|v| v.as_ref())
        }
        pub fn key(
            &self,
        ) -> Result<&Vec<super::key::Data>, ::prisma_client_rust::RelationNotFetchedError> {
            self.key
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(key),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Domain(super::domain::UniqueArgs),
        Key(super::key::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Domain(args) => {
                    let mut selections = < super :: domain :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(domain::NAME, None, [], selections)
                }
                Self::Key(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(
                        <super::key::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    );
                    ::prisma_client_rust::Selection::new(
                        key::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetDisplayName(String),
        SetHandle(String),
        ConnectDomain(super::domain::UniqueWhereParam),
        SetDomainId(String),
        ConnectKey(Vec<super::key::UniqueWhereParam>),
        DisconnectKey(Vec<super::key::UniqueWhereParam>),
        SetKey(Vec<super::key::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetDisplayName(value) => (
                    display_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetHandle(value) => (
                    handle::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectDomain(where_param) => (
                    domain::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::domain::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetDomainId(value) => (
                    domain_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectKey(where_params) => (
                    key::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::key::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectKey(where_params) => (
                    key::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::key::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetKey(where_params) => (
                    key::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::key::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(String),
        DisplayName(String),
        Handle(String),
        DomainId(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::DisplayName(value) => Self::SetDisplayName(value),
                UncheckedSetParam::Handle(value) => Self::SetHandle(value),
                UncheckedSetParam::DomainId(value) => Self::SetDomainId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        DisplayName(::prisma_client_rust::Direction),
        Handle(::prisma_client_rust::Direction),
        DomainId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::DisplayName(direction) => (
                    display_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Handle(direction) => (
                    handle::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::DomainId(direction) => (
                    domain_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        DisplayName(_prisma::read_filters::StringFilter),
        Handle(_prisma::read_filters::StringFilter),
        DomainIs(Vec<super::domain::WhereParam>),
        DomainIsNot(Vec<super::domain::WhereParam>),
        DomainId(_prisma::read_filters::StringFilter),
        KeySome(Vec<super::key::WhereParam>),
        KeyEvery(Vec<super::key::WhereParam>),
        KeyNone(Vec<super::key::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::DisplayName(value) => (display_name::NAME, value.into()),
                Self::Handle(value) => (handle::NAME, value.into()),
                Self::DomainIs(where_params) => (
                    domain::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DomainIsNot(where_params) => (
                    domain::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DomainId(value) => (domain_id::NAME, value.into()),
                Self::KeySome(where_params) => (
                    key::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::KeyEvery(where_params) => (
                    key::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::KeyNone(where_params) => (
                    key::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        HandleEquals(String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::HandleEquals(value) => {
                    Self::Handle(_prisma::read_filters::StringFilter::Equals(value))
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(display_name::NAME),
                ::prisma_client_rust::sel(handle::NAME),
                ::prisma_client_rust::sel(domain_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            display_name: String,
            handle: String,
            domain: super::domain::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                display_name::set(display_name),
                handle::set(handle),
                domain::connect(domain),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            display_name: String,
            handle: String,
            domain_id: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                display_name::set(display_name),
                handle::set(handle),
                domain_id::set(domain_id),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(display_name, handle, domain_id, mut _params)| {
                    _params.extend([
                        display_name::set(display_name),
                        handle::set(handle),
                        domain_id::set(domain_id),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (display_name, handle, domain, mut _params): (
                String,
                String,
                super::domain::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                display_name::set(display_name),
                handle::set(handle),
                domain::connect(domain),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod key {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "Key";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod actor {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "actor";
        pub struct Fetch(pub actor::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<actor::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Actor(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(actor::UniqueArgs::new())
        }
        pub struct Connect(actor::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectActor(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: actor::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<actor::WhereParam>) -> WhereParam {
            WhereParam::ActorIs(value)
        }
        pub fn is_not(value: Vec<actor::WhereParam>) -> WhereParam {
            WhereParam::ActorIsNot(value)
        }
        pub enum Include {
            Select(Vec<actor::SelectParam>),
            Include(Vec<actor::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Actor(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <actor::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <actor::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("actor", None, [], selections)
            }
            pub fn select(nested_selections: Vec<actor::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<actor::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<actor::SelectParam>),
            Include(Vec<actor::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Actor(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <actor::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("actor", None, [], selections)
            }
            pub fn select(nested_selections: Vec<actor::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<actor::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod actor_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "actorId";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetActorId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ActorId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ActorId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            ActorId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ActorId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ActorId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod private_key {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "private_key";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPrivateKey(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::PrivateKey(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::PrivateKey(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::PrivateKey(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            PrivateKey,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::PrivateKey(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::PrivateKey(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod public_key {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "public_key";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPublicKey(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::PublicKey(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::PublicKey(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::PublicKey(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            PublicKey,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::PublicKey(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::PublicKey(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod key_type {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "key_type";
        pub struct Set(pub self::KeyType);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetKeyType(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::KeyType(v)
            }
        }
        pub fn set<T: From<Set>>(value: self::KeyType) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::KeyType(direction)
        }
        pub fn equals(value: self::KeyType) -> WhereParam {
            WhereParam::KeyType(_prisma::read_filters::KeyTypeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::KeyTypeFilter,
            KeyType,
            {
                fn in_vec(_: Vec<super::super::KeyType>) -> InVec;
                fn not_in_vec(_: Vec<super::super::KeyType>) -> NotInVec;
                fn not(_: super::super::KeyType) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::KeyType(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::KeyType(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub fn create(
        actor: super::actor::UniqueWhereParam,
        name: String,
        private_key: String,
        public_key: String,
        _params: Vec<SetParam>,
    ) -> (
        super::actor::UniqueWhereParam,
        String,
        String,
        String,
        Vec<SetParam>,
    ) {
        (actor, name, private_key, public_key, _params)
    }
    pub fn create_unchecked(
        actor_id: String,
        name: String,
        private_key: String,
        public_key: String,
        _params: Vec<SetParam>,
    ) -> (String, String, String, String, Vec<SetParam>) {
        (actor_id, name, private_key, public_key, _params)
    }
    #[macro_export]
    macro_rules ! _select_key { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: key :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: key :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: key :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: key :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: key :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: key :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , actor , actor_id , name , private_key , public_key , key_type } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: key :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: key :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: key :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: key :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "actor" , "actorId" , "name" , "private_key" , "public_key" , "key_type"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: key :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; actor : $ selection_mode : ident { $ ($ selections : tt) + }) => { actor :: Data } ; (@ field_type ; actor) => { crate :: prisma :: actor :: Data } ; (@ field_type ; actor_id) => { String } ; (@ field_type ; name) => { String } ; (@ field_type ; private_key) => { String } ; (@ field_type ; public_key) => { String } ; (@ field_type ; key_type) => { crate :: prisma :: KeyType } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Key" , available relations are "id, actor, actor_id, name, private_key, public_key, key_type")) } ; (@ field_module ; actor : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: actor :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: id :: Select) } ; (@ selection_field_to_selection_param ; actor $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: actor :: Select :: $ selection_mode (crate :: prisma :: actor :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; actor $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: actor :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; actor_id) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: actor_id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: name :: Select) } ; (@ selection_field_to_selection_param ; private_key) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: private_key :: Select) } ; (@ selection_field_to_selection_param ; public_key) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: public_key :: Select) } ; (@ selection_field_to_selection_param ; key_type) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: key_type :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: key :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; actor) => { "actor" } ; (@ field_serde_name ; actor_id) => { "actorId" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; private_key) => { "private_key" } ; (@ field_serde_name ; public_key) => { "public_key" } ; (@ field_serde_name ; key_type) => { "key_type" } ; }
    pub use _select_key as select;
    pub enum SelectParam {
        Id(id::Select),
        Actor(actor::Select),
        ActorId(actor_id::Select),
        Name(name::Select),
        PrivateKey(private_key::Select),
        PublicKey(public_key::Select),
        KeyType(key_type::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Actor(data) => data.to_selection(),
                Self::ActorId(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::PrivateKey(data) => data.to_selection(),
                Self::PublicKey(data) => data.to_selection(),
                Self::KeyType(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_key { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: key :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: key :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: key :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: key :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: key :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: key :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: key :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: key :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { actor } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub actor_id : String , pub name : String , pub private_key : String , pub public_key : String , pub key_type : crate :: prisma :: KeyType , $ (pub $ field : crate :: prisma :: key :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (actor_id) , stringify ! (name) , stringify ! (private_key) , stringify ! (public_key) , stringify ! (key_type)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: key :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: key :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: key :: actor_id :: NAME , & self . actor_id) ? ; state . serialize_field (crate :: prisma :: key :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: key :: private_key :: NAME , & self . private_key) ? ; state . serialize_field (crate :: prisma :: key :: public_key :: NAME , & self . public_key) ? ; state . serialize_field (crate :: prisma :: key :: key_type :: NAME , & self . key_type) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , actor_id , name , private_key , public_key , key_type } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: key :: $ field :: NAME) , + , crate :: prisma :: key :: id :: NAME , crate :: prisma :: key :: actor_id :: NAME , crate :: prisma :: key :: name :: NAME , crate :: prisma :: key :: private_key :: NAME , crate :: prisma :: key :: public_key :: NAME , crate :: prisma :: key :: key_type :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: key :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: key :: id :: NAME => Ok (Field :: id) , crate :: prisma :: key :: actor_id :: NAME => Ok (Field :: actor_id) , crate :: prisma :: key :: name :: NAME => Ok (Field :: name) , crate :: prisma :: key :: private_key :: NAME => Ok (Field :: private_key) , crate :: prisma :: key :: public_key :: NAME => Ok (Field :: public_key) , crate :: prisma :: key :: key_type :: NAME => Ok (Field :: key_type) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut actor_id = None ; let mut name = None ; let mut private_key = None ; let mut public_key = None ; let mut key_type = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: actor_id => { if actor_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: actor_id :: NAME)) ; } actor_id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: private_key => { if private_key . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: private_key :: NAME)) ; } private_key = Some (map . next_value () ?) ; } Field :: public_key => { if public_key . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: public_key :: NAME)) ; } public_key = Some (map . next_value () ?) ; } Field :: key_type => { if key_type . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: key_type :: NAME)) ; } key_type = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: id :: NAME)) ? ; let actor_id = actor_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: actor_id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: name :: NAME)) ? ; let private_key = private_key . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: private_key :: NAME)) ? ; let public_key = public_key . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: public_key :: NAME)) ? ; let key_type = key_type . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: key_type :: NAME)) ? ; Ok (Data { id , actor_id , name , private_key , public_key , key_type , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "actor" , "actorId" , "name" , "private_key" , "public_key" , "key_type"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: key :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; actor : $ selection_mode : ident { $ ($ selections : tt) + }) => { actor :: Data } ; (@ field_type ; actor) => { crate :: prisma :: actor :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Key" , available relations are "actor")) } ; (@ field_module ; actor : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: actor :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; actor $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: key :: IncludeParam > :: into (crate :: prisma :: key :: actor :: Include :: $ selection_mode (crate :: prisma :: actor :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; actor $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: key :: IncludeParam > :: into (crate :: prisma :: key :: actor :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: key :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; actor) => { "actor" } ; (@ field_serde_name ; actor_id) => { "actorId" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; private_key) => { "private_key" } ; (@ field_serde_name ; public_key) => { "public_key" } ; (@ field_serde_name ; key_type) => { "key_type" } ; }
    pub use _include_key as include;
    pub enum IncludeParam {
        Id(id::Include),
        Actor(actor::Include),
        ActorId(actor_id::Include),
        Name(name::Include),
        PrivateKey(private_key::Include),
        PublicKey(public_key::Include),
        KeyType(key_type::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Actor(data) => data.to_selection(),
                Self::ActorId(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::PrivateKey(data) => data.to_selection(),
                Self::PublicKey(data) => data.to_selection(),
                Self::KeyType(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_key { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: key struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "actorId")] pub actor_id : String , # [serde (rename = "name")] pub name : String , # [serde (rename = "private_key")] pub private_key : String , # [serde (rename = "public_key")] pub public_key : String , # [serde (rename = "key_type")] pub key_type : crate :: prisma :: KeyType } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_key as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "actor")]
        pub actor: Option<Box<super::actor::Data>>,
        #[serde(rename = "actorId")]
        pub actor_id: String,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "private_key")]
        pub private_key: String,
        #[serde(rename = "public_key")]
        pub public_key: String,
        #[serde(rename = "key_type")]
        pub key_type: super::KeyType,
    }
    impl Data {
        pub fn actor(
            &self,
        ) -> Result<&super::actor::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.actor
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(actor),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Actor(super::actor::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Actor(args) => {
                    let mut selections = < super :: actor :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(actor::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        ConnectActor(super::actor::UniqueWhereParam),
        SetActorId(String),
        SetName(String),
        SetPrivateKey(String),
        SetPublicKey(String),
        SetKeyType(super::KeyType),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectActor(where_param) => (
                    actor::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::actor::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetActorId(value) => (
                    actor_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetName(value) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetPrivateKey(value) => (
                    private_key::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetPublicKey(value) => (
                    public_key::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetKeyType(value) => (
                    key_type::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(String),
        ActorId(String),
        Name(String),
        PrivateKey(String),
        PublicKey(String),
        KeyType(super::KeyType),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::ActorId(value) => Self::SetActorId(value),
                UncheckedSetParam::Name(value) => Self::SetName(value),
                UncheckedSetParam::PrivateKey(value) => Self::SetPrivateKey(value),
                UncheckedSetParam::PublicKey(value) => Self::SetPublicKey(value),
                UncheckedSetParam::KeyType(value) => Self::SetKeyType(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        ActorId(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        PrivateKey(::prisma_client_rust::Direction),
        PublicKey(::prisma_client_rust::Direction),
        KeyType(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ActorId(direction) => (
                    actor_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::PrivateKey(direction) => (
                    private_key::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::PublicKey(direction) => (
                    public_key::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::KeyType(direction) => (
                    key_type::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        ActorIs(Vec<super::actor::WhereParam>),
        ActorIsNot(Vec<super::actor::WhereParam>),
        ActorId(_prisma::read_filters::StringFilter),
        Name(_prisma::read_filters::StringFilter),
        PrivateKey(_prisma::read_filters::StringFilter),
        PublicKey(_prisma::read_filters::StringFilter),
        KeyType(_prisma::read_filters::KeyTypeFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::ActorIs(where_params) => (
                    actor::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ActorIsNot(where_params) => (
                    actor::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ActorId(value) => (actor_id::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::PrivateKey(value) => (private_key::NAME, value.into()),
                Self::PublicKey(value) => (public_key::NAME, value.into()),
                Self::KeyType(value) => (key_type::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(actor_id::NAME),
                ::prisma_client_rust::sel(name::NAME),
                ::prisma_client_rust::sel(private_key::NAME),
                ::prisma_client_rust::sel(public_key::NAME),
                ::prisma_client_rust::sel(key_type::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            actor: super::actor::UniqueWhereParam,
            name: String,
            private_key: String,
            public_key: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                actor::connect(actor),
                name::set(name),
                private_key::set(private_key),
                public_key::set(public_key),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            actor_id: String,
            name: String,
            private_key: String,
            public_key: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                actor_id::set(actor_id),
                name::set(name),
                private_key::set(private_key),
                public_key::set(public_key),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(actor_id, name, private_key, public_key, mut _params)| {
                    _params.extend([
                        actor_id::set(actor_id),
                        name::set(name),
                        private_key::set(private_key),
                        public_key::set(public_key),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (actor, name, private_key, public_key, mut _params): (
                super::actor::UniqueWhereParam,
                String,
                String,
                String,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                actor::connect(actor),
                name::set(name),
                private_key::set(private_key),
                public_key::set(public_key),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod publisher {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "Publisher";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::NameEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod repositories {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "repositories";
        pub struct Fetch(pub package_repository::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<package_repository::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: package_repository::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: package_repository::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Repositories(v)
            }
        }
        pub fn fetch(params: Vec<package_repository::WhereParam>) -> Fetch {
            Fetch(package_repository::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<package_repository::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectRepositories(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<package_repository::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<package_repository::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectRepositories(params)
        }
        pub fn set(params: Vec<package_repository::UniqueWhereParam>) -> SetParam {
            SetParam::SetRepositories(params)
        }
        pub fn some(value: Vec<package_repository::WhereParam>) -> WhereParam {
            WhereParam::RepositoriesSome(value)
        }
        pub fn every(value: Vec<package_repository::WhereParam>) -> WhereParam {
            WhereParam::RepositoriesEvery(value)
        }
        pub fn none(value: Vec<package_repository::WhereParam>) -> WhereParam {
            WhereParam::RepositoriesNone(value)
        }
        pub enum Include {
            Select(
                package_repository::ManyArgs,
                Vec<package_repository::SelectParam>,
            ),
            Include(
                package_repository::ManyArgs,
                Vec<package_repository::IncludeParam>,
            ),
            Fetch(package_repository::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Repositories(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < package_repository :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < package_repository :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: package_repository::ManyArgs,
                nested_selections: Vec<package_repository::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: package_repository::ManyArgs,
                nested_selections: Vec<package_repository::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                package_repository::ManyArgs,
                Vec<package_repository::SelectParam>,
            ),
            Include(
                package_repository::ManyArgs,
                Vec<package_repository::IncludeParam>,
            ),
            Fetch(package_repository::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Repositories(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < package_repository :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: package_repository::ManyArgs,
                nested_selections: Vec<package_repository::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: package_repository::ManyArgs,
                nested_selections: Vec<package_repository::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod gate {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "Gate";
        pub struct Fetch(pub gate::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<gate::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: gate::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: gate::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Gate(v)
            }
        }
        pub fn fetch(params: Vec<gate::WhereParam>) -> Fetch {
            Fetch(gate::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<gate::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectGate(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<gate::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<gate::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectGate(params)
        }
        pub fn set(params: Vec<gate::UniqueWhereParam>) -> SetParam {
            SetParam::SetGate(params)
        }
        pub fn some(value: Vec<gate::WhereParam>) -> WhereParam {
            WhereParam::GateSome(value)
        }
        pub fn every(value: Vec<gate::WhereParam>) -> WhereParam {
            WhereParam::GateEvery(value)
        }
        pub fn none(value: Vec<gate::WhereParam>) -> WhereParam {
            WhereParam::GateNone(value)
        }
        pub enum Include {
            Select(gate::ManyArgs, Vec<gate::SelectParam>),
            Include(gate::ManyArgs, Vec<gate::IncludeParam>),
            Fetch(gate::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Gate(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <gate::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <gate::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(args: gate::ManyArgs, nested_selections: Vec<gate::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: gate::ManyArgs,
                nested_selections: Vec<gate::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(gate::ManyArgs, Vec<gate::SelectParam>),
            Include(gate::ManyArgs, Vec<gate::IncludeParam>),
            Fetch(gate::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Gate(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <gate::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(args: gate::ManyArgs, nested_selections: Vec<gate::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: gate::ManyArgs,
                nested_selections: Vec<gate::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(name: String, _params: Vec<SetParam>) -> (String, Vec<SetParam>) {
        (name, _params)
    }
    pub fn create_unchecked(name: String, _params: Vec<SetParam>) -> (String, Vec<SetParam>) {
        (name, _params)
    }
    #[macro_export]
    macro_rules ! _select_publisher { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: publisher :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: publisher :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: publisher :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: publisher :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: publisher :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: publisher :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , repositories , gate } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: publisher :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: publisher :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: publisher :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: publisher :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: publisher :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: publisher :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "repositories" , "Gate"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: publisher :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; name) => { String } ; (@ field_type ; repositories : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < repositories :: Data > } ; (@ field_type ; repositories) => { Vec < crate :: prisma :: package_repository :: Data > } ; (@ field_type ; gate : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < gate :: Data > } ; (@ field_type ; gate) => { Vec < crate :: prisma :: gate :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Publisher" , available relations are "id, name, repositories, gate")) } ; (@ field_module ; repositories : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: package_repository :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; gate : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: gate :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: publisher :: SelectParam > :: into (crate :: prisma :: publisher :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: publisher :: SelectParam > :: into (crate :: prisma :: publisher :: name :: Select) } ; (@ selection_field_to_selection_param ; repositories $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: publisher :: SelectParam > :: into (crate :: prisma :: publisher :: repositories :: Select :: $ selection_mode (crate :: prisma :: package_repository :: ManyArgs :: new (crate :: prisma :: package_repository :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: package_repository :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; repositories $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: publisher :: SelectParam > :: into (crate :: prisma :: publisher :: repositories :: Select :: Fetch (crate :: prisma :: package_repository :: ManyArgs :: new (crate :: prisma :: package_repository :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; gate $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: publisher :: SelectParam > :: into (crate :: prisma :: publisher :: gate :: Select :: $ selection_mode (crate :: prisma :: gate :: ManyArgs :: new (crate :: prisma :: gate :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: gate :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; gate $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: publisher :: SelectParam > :: into (crate :: prisma :: publisher :: gate :: Select :: Fetch (crate :: prisma :: gate :: ManyArgs :: new (crate :: prisma :: gate :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: publisher :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; repositories) => { "repositories" } ; (@ field_serde_name ; gate) => { "Gate" } ; }
    pub use _select_publisher as select;
    pub enum SelectParam {
        Id(id::Select),
        Name(name::Select),
        Repositories(repositories::Select),
        Gate(gate::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Repositories(data) => data.to_selection(),
                Self::Gate(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_publisher { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: publisher :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: publisher :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: publisher :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: publisher :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: publisher :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: publisher :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: publisher :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: publisher :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { repositories , gate } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub name : String , $ (pub $ field : crate :: prisma :: publisher :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: publisher :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: publisher :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: publisher :: name :: NAME , & self . name) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: publisher :: $ field :: NAME) , + , crate :: prisma :: publisher :: id :: NAME , crate :: prisma :: publisher :: name :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: publisher :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: publisher :: id :: NAME => Ok (Field :: id) , crate :: prisma :: publisher :: name :: NAME => Ok (Field :: name) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: publisher :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: publisher :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: publisher :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: publisher :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: publisher :: id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: publisher :: name :: NAME)) ? ; Ok (Data { id , name , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "repositories" , "Gate"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: publisher :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; repositories : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < repositories :: Data > } ; (@ field_type ; repositories) => { Vec < crate :: prisma :: package_repository :: Data > } ; (@ field_type ; gate : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < gate :: Data > } ; (@ field_type ; gate) => { Vec < crate :: prisma :: gate :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Publisher" , available relations are "repositories, gate")) } ; (@ field_module ; repositories : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: package_repository :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; gate : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: gate :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; repositories $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: publisher :: IncludeParam > :: into (crate :: prisma :: publisher :: repositories :: Include :: $ selection_mode (crate :: prisma :: package_repository :: ManyArgs :: new (crate :: prisma :: package_repository :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: package_repository :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; repositories $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: publisher :: IncludeParam > :: into (crate :: prisma :: publisher :: repositories :: Include :: Fetch (crate :: prisma :: package_repository :: ManyArgs :: new (crate :: prisma :: package_repository :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; gate $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: publisher :: IncludeParam > :: into (crate :: prisma :: publisher :: gate :: Include :: $ selection_mode (crate :: prisma :: gate :: ManyArgs :: new (crate :: prisma :: gate :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: gate :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; gate $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: publisher :: IncludeParam > :: into (crate :: prisma :: publisher :: gate :: Include :: Fetch (crate :: prisma :: gate :: ManyArgs :: new (crate :: prisma :: gate :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: publisher :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; repositories) => { "repositories" } ; (@ field_serde_name ; gate) => { "Gate" } ; }
    pub use _include_publisher as include;
    pub enum IncludeParam {
        Id(id::Include),
        Name(name::Include),
        Repositories(repositories::Include),
        Gate(gate::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Repositories(data) => data.to_selection(),
                Self::Gate(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_publisher { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: publisher struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "name")] pub name : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_publisher as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "repositories")]
        pub repositories: Option<Vec<super::package_repository::Data>>,
        #[serde(rename = "Gate")]
        pub gate: Option<Vec<super::gate::Data>>,
    }
    impl Data {
        pub fn repositories(
            &self,
        ) -> Result<
            &Vec<super::package_repository::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.repositories
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(repositories),
                ))
        }
        pub fn gate(
            &self,
        ) -> Result<&Vec<super::gate::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.gate
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(gate),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Repositories(super::package_repository::ManyArgs),
        Gate(super::gate::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Repositories(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: package_repository :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        repositories::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Gate(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(
                        <super::gate::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    );
                    ::prisma_client_rust::Selection::new(
                        gate::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetName(String),
        ConnectRepositories(Vec<super::package_repository::UniqueWhereParam>),
        DisconnectRepositories(Vec<super::package_repository::UniqueWhereParam>),
        SetRepositories(Vec<super::package_repository::UniqueWhereParam>),
        ConnectGate(Vec<super::gate::UniqueWhereParam>),
        DisconnectGate(Vec<super::gate::UniqueWhereParam>),
        SetGate(Vec<super::gate::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetName(value) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectRepositories(where_params) => (
                    repositories::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::package_repository::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectRepositories(where_params) => (
                    repositories::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::package_repository::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetRepositories(where_params) => (
                    repositories::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::package_repository::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectGate(where_params) => (
                    gate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::gate::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectGate(where_params) => (
                    gate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::gate::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetGate(where_params) => (
                    gate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::gate::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(String),
        Name(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Name(value) => Self::SetName(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        Name(_prisma::read_filters::StringFilter),
        RepositoriesSome(Vec<super::package_repository::WhereParam>),
        RepositoriesEvery(Vec<super::package_repository::WhereParam>),
        RepositoriesNone(Vec<super::package_repository::WhereParam>),
        GateSome(Vec<super::gate::WhereParam>),
        GateEvery(Vec<super::gate::WhereParam>),
        GateNone(Vec<super::gate::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::RepositoriesSome(where_params) => (
                    repositories::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RepositoriesEvery(where_params) => (
                    repositories::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RepositoriesNone(where_params) => (
                    repositories::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::GateSome(where_params) => (
                    gate::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::GateEvery(where_params) => (
                    gate::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::GateNone(where_params) => (
                    gate::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        NameEquals(String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::NameEquals(value) => {
                    Self::Name(_prisma::read_filters::StringFilter::Equals(value))
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(name::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(self, name: String, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.extend([name::set(name)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            name: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([name::set(name)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(name, mut _params)| {
                    _params.extend([name::set(name)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (name, mut _params): (String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([name::set(name)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod package_repository {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "PackageRepository";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod publisher {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "publisher";
        pub struct Fetch(pub publisher::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<publisher::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Publisher(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(publisher::UniqueArgs::new())
        }
        pub struct Connect(publisher::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectPublisher(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: publisher::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<publisher::WhereParam>) -> WhereParam {
            WhereParam::PublisherIs(value)
        }
        pub fn is_not(value: Vec<publisher::WhereParam>) -> WhereParam {
            WhereParam::PublisherIsNot(value)
        }
        pub enum Include {
            Select(Vec<publisher::SelectParam>),
            Include(Vec<publisher::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Publisher(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = < publisher :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <publisher::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("publisher", None, [], selections)
            }
            pub fn select(nested_selections: Vec<publisher::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<publisher::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<publisher::SelectParam>),
            Include(Vec<publisher::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Publisher(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <publisher::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("publisher", None, [], selections)
            }
            pub fn select(nested_selections: Vec<publisher::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<publisher::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod publisher_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "publisherId";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPublisherId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::PublisherId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::PublisherId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::PublisherId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            PublisherId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::PublisherId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::PublisherId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub fn create(
        name: String,
        publisher: super::publisher::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (String, super::publisher::UniqueWhereParam, Vec<SetParam>) {
        (name, publisher, _params)
    }
    pub fn create_unchecked(
        name: String,
        publisher_id: String,
        _params: Vec<SetParam>,
    ) -> (String, String, Vec<SetParam>) {
        (name, publisher_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_package_repository { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: package_repository :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: package_repository :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: package_repository :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: package_repository :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: package_repository :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: package_repository :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , publisher , publisher_id } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: package_repository :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: package_repository :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: package_repository :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: package_repository :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: package_repository :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: package_repository :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "publisher" , "publisherId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: package_repository :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; name) => { String } ; (@ field_type ; publisher : $ selection_mode : ident { $ ($ selections : tt) + }) => { publisher :: Data } ; (@ field_type ; publisher) => { crate :: prisma :: publisher :: Data } ; (@ field_type ; publisher_id) => { String } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "PackageRepository" , available relations are "id, name, publisher, publisher_id")) } ; (@ field_module ; publisher : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: publisher :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: package_repository :: SelectParam > :: into (crate :: prisma :: package_repository :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: package_repository :: SelectParam > :: into (crate :: prisma :: package_repository :: name :: Select) } ; (@ selection_field_to_selection_param ; publisher $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: package_repository :: SelectParam > :: into (crate :: prisma :: package_repository :: publisher :: Select :: $ selection_mode (crate :: prisma :: publisher :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; publisher $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: package_repository :: SelectParam > :: into (crate :: prisma :: package_repository :: publisher :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; publisher_id) => { Into :: < crate :: prisma :: package_repository :: SelectParam > :: into (crate :: prisma :: package_repository :: publisher_id :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: package_repository :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; publisher) => { "publisher" } ; (@ field_serde_name ; publisher_id) => { "publisherId" } ; }
    pub use _select_package_repository as select;
    pub enum SelectParam {
        Id(id::Select),
        Name(name::Select),
        Publisher(publisher::Select),
        PublisherId(publisher_id::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Publisher(data) => data.to_selection(),
                Self::PublisherId(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_package_repository { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: package_repository :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: package_repository :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: package_repository :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: package_repository :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: package_repository :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: package_repository :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: package_repository :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: package_repository :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { publisher } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub name : String , pub publisher_id : String , $ (pub $ field : crate :: prisma :: package_repository :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (publisher_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: package_repository :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: package_repository :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: package_repository :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: package_repository :: publisher_id :: NAME , & self . publisher_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name , publisher_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: package_repository :: $ field :: NAME) , + , crate :: prisma :: package_repository :: id :: NAME , crate :: prisma :: package_repository :: name :: NAME , crate :: prisma :: package_repository :: publisher_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: package_repository :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: package_repository :: id :: NAME => Ok (Field :: id) , crate :: prisma :: package_repository :: name :: NAME => Ok (Field :: name) , crate :: prisma :: package_repository :: publisher_id :: NAME => Ok (Field :: publisher_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; let mut publisher_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: package_repository :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: package_repository :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: publisher_id => { if publisher_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: package_repository :: publisher_id :: NAME)) ; } publisher_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: package_repository :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: package_repository :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: package_repository :: id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: package_repository :: name :: NAME)) ? ; let publisher_id = publisher_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: package_repository :: publisher_id :: NAME)) ? ; Ok (Data { id , name , publisher_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "publisher" , "publisherId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: package_repository :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; publisher : $ selection_mode : ident { $ ($ selections : tt) + }) => { publisher :: Data } ; (@ field_type ; publisher) => { crate :: prisma :: publisher :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "PackageRepository" , available relations are "publisher")) } ; (@ field_module ; publisher : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: publisher :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; publisher $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: package_repository :: IncludeParam > :: into (crate :: prisma :: package_repository :: publisher :: Include :: $ selection_mode (crate :: prisma :: publisher :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; publisher $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: package_repository :: IncludeParam > :: into (crate :: prisma :: package_repository :: publisher :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: package_repository :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; publisher) => { "publisher" } ; (@ field_serde_name ; publisher_id) => { "publisherId" } ; }
    pub use _include_package_repository as include;
    pub enum IncludeParam {
        Id(id::Include),
        Name(name::Include),
        Publisher(publisher::Include),
        PublisherId(publisher_id::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Publisher(data) => data.to_selection(),
                Self::PublisherId(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_package_repository { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: package_repository struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "name")] pub name : String , # [serde (rename = "publisherId")] pub publisher_id : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_package_repository as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "publisher")]
        pub publisher: Option<Box<super::publisher::Data>>,
        #[serde(rename = "publisherId")]
        pub publisher_id: String,
    }
    impl Data {
        pub fn publisher(
            &self,
        ) -> Result<&super::publisher::Data, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.publisher
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(publisher),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Publisher(super::publisher::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Publisher(args) => {
                    let mut selections = < super :: publisher :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(publisher::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetName(String),
        ConnectPublisher(super::publisher::UniqueWhereParam),
        SetPublisherId(String),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetName(value) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectPublisher(where_param) => (
                    publisher::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::publisher::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetPublisherId(value) => (
                    publisher_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(String),
        Name(String),
        PublisherId(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Name(value) => Self::SetName(value),
                UncheckedSetParam::PublisherId(value) => Self::SetPublisherId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        PublisherId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::PublisherId(direction) => (
                    publisher_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        Name(_prisma::read_filters::StringFilter),
        PublisherIs(Vec<super::publisher::WhereParam>),
        PublisherIsNot(Vec<super::publisher::WhereParam>),
        PublisherId(_prisma::read_filters::StringFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::PublisherIs(where_params) => (
                    publisher::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::PublisherIsNot(where_params) => (
                    publisher::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::PublisherId(value) => (publisher_id::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(name::NAME),
                ::prisma_client_rust::sel(publisher_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            name: String,
            publisher: super::publisher::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([name::set(name), publisher::connect(publisher)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            name: String,
            publisher_id: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([name::set(name), publisher_id::set(publisher_id)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(String, String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(name, publisher_id, mut _params)| {
                    _params.extend([name::set(name), publisher_id::set(publisher_id)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (name, publisher, mut _params): (
                String,
                super::publisher::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([name::set(name), publisher::connect(publisher)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod gate {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "Gate";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod version {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "version";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetVersion(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Version(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Version(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Version(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Version,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Version(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Version(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod branch {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "branch";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetBranch(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Branch(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Branch(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Branch(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Branch,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Branch(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Branch(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod publisher {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "publisher";
        pub struct Fetch(pub publisher::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<publisher::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Publisher(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(publisher::UniqueArgs::new())
        }
        pub struct Connect(publisher::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectPublisher(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: publisher::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<publisher::WhereParam>) -> WhereParam {
            WhereParam::PublisherIs(value)
        }
        pub fn is_not(value: Vec<publisher::WhereParam>) -> WhereParam {
            WhereParam::PublisherIsNot(value)
        }
        pub enum Include {
            Select(Vec<publisher::SelectParam>),
            Include(Vec<publisher::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Publisher(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = < publisher :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <publisher::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("publisher", None, [], selections)
            }
            pub fn select(nested_selections: Vec<publisher::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<publisher::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<publisher::SelectParam>),
            Include(Vec<publisher::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Publisher(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <publisher::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("publisher", None, [], selections)
            }
            pub fn select(nested_selections: Vec<publisher::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<publisher::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod transforms {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "transforms";
        pub struct Set(pub ::prisma_client_rust::serde_json::Value);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTransforms(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Transforms(v)
            }
        }
        pub fn set<T: From<Set>>(value: ::prisma_client_rust::serde_json::Value) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Transforms(direction)
        }
        pub fn equals(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Transforms(_prisma::read_filters::JsonFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::JsonFilter,
            Transforms,
            {
                fn path(_: Vec<String>) -> Path;
                fn string_contains(_: String) -> StringContains;
                fn string_starts_with(_: String) -> StringStartsWith;
                fn string_ends_with(_: String) -> StringEndsWith;
                fn array_contains(
                    _: Option<::prisma_client_rust::serde_json::Value>,
                ) -> ArrayContains;
                fn array_starts_with(
                    _: Option<::prisma_client_rust::serde_json::Value>,
                ) -> ArrayStartsWith;
                fn array_ends_with(
                    _: Option<::prisma_client_rust::serde_json::Value>,
                ) -> ArrayEndsWith;
                fn lt(_: ::prisma_client_rust::serde_json::Value) -> Lt;
                fn lte(_: ::prisma_client_rust::serde_json::Value) -> Lte;
                fn gt(_: ::prisma_client_rust::serde_json::Value) -> Gt;
                fn gte(_: ::prisma_client_rust::serde_json::Value) -> Gte;
                fn not(_: ::prisma_client_rust::serde_json::Value) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Transforms(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Transforms(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod publisher_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "publisherId";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPublisherId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::PublisherId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::PublisherId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::PublisherId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            PublisherId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::PublisherId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::PublisherId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod component {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "Component";
        pub struct Fetch(pub component::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<component::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: component::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: component::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Component(v)
            }
        }
        pub fn fetch(params: Vec<component::WhereParam>) -> Fetch {
            Fetch(component::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<component::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectComponent(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<component::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<component::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectComponent(params)
        }
        pub fn set(params: Vec<component::UniqueWhereParam>) -> SetParam {
            SetParam::SetComponent(params)
        }
        pub fn some(value: Vec<component::WhereParam>) -> WhereParam {
            WhereParam::ComponentSome(value)
        }
        pub fn every(value: Vec<component::WhereParam>) -> WhereParam {
            WhereParam::ComponentEvery(value)
        }
        pub fn none(value: Vec<component::WhereParam>) -> WhereParam {
            WhereParam::ComponentNone(value)
        }
        pub enum Include {
            Select(component::ManyArgs, Vec<component::SelectParam>),
            Include(component::ManyArgs, Vec<component::IncludeParam>),
            Fetch(component::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Component(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = < component :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <component::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: component::ManyArgs,
                nested_selections: Vec<component::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: component::ManyArgs,
                nested_selections: Vec<component::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(component::ManyArgs, Vec<component::SelectParam>),
            Include(component::ManyArgs, Vec<component::IncludeParam>),
            Fetch(component::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Component(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <component::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: component::ManyArgs,
                nested_selections: Vec<component::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: component::ManyArgs,
                nested_selections: Vec<component::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod component_change {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "ComponentChange";
        pub struct Fetch(pub component_change::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<component_change::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: component_change::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: component_change::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::ComponentChange(v)
            }
        }
        pub fn fetch(params: Vec<component_change::WhereParam>) -> Fetch {
            Fetch(component_change::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<component_change::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectComponentChange(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<component_change::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<component_change::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectComponentChange(params)
        }
        pub fn set(params: Vec<component_change::UniqueWhereParam>) -> SetParam {
            SetParam::SetComponentChange(params)
        }
        pub fn some(value: Vec<component_change::WhereParam>) -> WhereParam {
            WhereParam::ComponentChangeSome(value)
        }
        pub fn every(value: Vec<component_change::WhereParam>) -> WhereParam {
            WhereParam::ComponentChangeEvery(value)
        }
        pub fn none(value: Vec<component_change::WhereParam>) -> WhereParam {
            WhereParam::ComponentChangeNone(value)
        }
        pub enum Include {
            Select(
                component_change::ManyArgs,
                Vec<component_change::SelectParam>,
            ),
            Include(
                component_change::ManyArgs,
                Vec<component_change::IncludeParam>,
            ),
            Fetch(component_change::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ComponentChange(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < component_change :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < component_change :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: component_change::ManyArgs,
                nested_selections: Vec<component_change::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: component_change::ManyArgs,
                nested_selections: Vec<component_change::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                component_change::ManyArgs,
                Vec<component_change::SelectParam>,
            ),
            Include(
                component_change::ManyArgs,
                Vec<component_change::IncludeParam>,
            ),
            Fetch(component_change::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ComponentChange(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < component_change :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: component_change::ManyArgs,
                nested_selections: Vec<component_change::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: component_change::ManyArgs,
                nested_selections: Vec<component_change::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(
        name: String,
        version: String,
        branch: String,
        publisher: super::publisher::UniqueWhereParam,
        transforms: ::prisma_client_rust::serde_json::Value,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        String,
        super::publisher::UniqueWhereParam,
        ::prisma_client_rust::serde_json::Value,
        Vec<SetParam>,
    ) {
        (name, version, branch, publisher, transforms, _params)
    }
    pub fn create_unchecked(
        name: String,
        version: String,
        branch: String,
        transforms: ::prisma_client_rust::serde_json::Value,
        publisher_id: String,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        String,
        ::prisma_client_rust::serde_json::Value,
        String,
        Vec<SetParam>,
    ) {
        (name, version, branch, transforms, publisher_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_gate { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: gate :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: gate :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: gate :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: gate :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: gate :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: gate :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , version , branch , publisher , transforms , publisher_id , component , component_change } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: gate :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: gate :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: gate :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: gate :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: gate :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: gate :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "version" , "branch" , "publisher" , "transforms" , "publisherId" , "Component" , "ComponentChange"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: gate :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; name) => { String } ; (@ field_type ; version) => { String } ; (@ field_type ; branch) => { String } ; (@ field_type ; publisher : $ selection_mode : ident { $ ($ selections : tt) + }) => { publisher :: Data } ; (@ field_type ; publisher) => { crate :: prisma :: publisher :: Data } ; (@ field_type ; transforms) => { :: prisma_client_rust :: serde_json :: Value } ; (@ field_type ; publisher_id) => { String } ; (@ field_type ; component : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < component :: Data > } ; (@ field_type ; component) => { Vec < crate :: prisma :: component :: Data > } ; (@ field_type ; component_change : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < component_change :: Data > } ; (@ field_type ; component_change) => { Vec < crate :: prisma :: component_change :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Gate" , available relations are "id, name, version, branch, publisher, transforms, publisher_id, component, component_change")) } ; (@ field_module ; publisher : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: publisher :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; component : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: component :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; component_change : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: component_change :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: gate :: SelectParam > :: into (crate :: prisma :: gate :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: gate :: SelectParam > :: into (crate :: prisma :: gate :: name :: Select) } ; (@ selection_field_to_selection_param ; version) => { Into :: < crate :: prisma :: gate :: SelectParam > :: into (crate :: prisma :: gate :: version :: Select) } ; (@ selection_field_to_selection_param ; branch) => { Into :: < crate :: prisma :: gate :: SelectParam > :: into (crate :: prisma :: gate :: branch :: Select) } ; (@ selection_field_to_selection_param ; publisher $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: gate :: SelectParam > :: into (crate :: prisma :: gate :: publisher :: Select :: $ selection_mode (crate :: prisma :: publisher :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; publisher $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: gate :: SelectParam > :: into (crate :: prisma :: gate :: publisher :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; transforms) => { Into :: < crate :: prisma :: gate :: SelectParam > :: into (crate :: prisma :: gate :: transforms :: Select) } ; (@ selection_field_to_selection_param ; publisher_id) => { Into :: < crate :: prisma :: gate :: SelectParam > :: into (crate :: prisma :: gate :: publisher_id :: Select) } ; (@ selection_field_to_selection_param ; component $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: gate :: SelectParam > :: into (crate :: prisma :: gate :: component :: Select :: $ selection_mode (crate :: prisma :: component :: ManyArgs :: new (crate :: prisma :: component :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: component :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; component $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: gate :: SelectParam > :: into (crate :: prisma :: gate :: component :: Select :: Fetch (crate :: prisma :: component :: ManyArgs :: new (crate :: prisma :: component :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; component_change $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: gate :: SelectParam > :: into (crate :: prisma :: gate :: component_change :: Select :: $ selection_mode (crate :: prisma :: component_change :: ManyArgs :: new (crate :: prisma :: component_change :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: component_change :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; component_change $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: gate :: SelectParam > :: into (crate :: prisma :: gate :: component_change :: Select :: Fetch (crate :: prisma :: component_change :: ManyArgs :: new (crate :: prisma :: component_change :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: gate :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; version) => { "version" } ; (@ field_serde_name ; branch) => { "branch" } ; (@ field_serde_name ; publisher) => { "publisher" } ; (@ field_serde_name ; transforms) => { "transforms" } ; (@ field_serde_name ; publisher_id) => { "publisherId" } ; (@ field_serde_name ; component) => { "Component" } ; (@ field_serde_name ; component_change) => { "ComponentChange" } ; }
    pub use _select_gate as select;
    pub enum SelectParam {
        Id(id::Select),
        Name(name::Select),
        Version(version::Select),
        Branch(branch::Select),
        Publisher(publisher::Select),
        Transforms(transforms::Select),
        PublisherId(publisher_id::Select),
        Component(component::Select),
        ComponentChange(component_change::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Version(data) => data.to_selection(),
                Self::Branch(data) => data.to_selection(),
                Self::Publisher(data) => data.to_selection(),
                Self::Transforms(data) => data.to_selection(),
                Self::PublisherId(data) => data.to_selection(),
                Self::Component(data) => data.to_selection(),
                Self::ComponentChange(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_gate { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: gate :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: gate :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: gate :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: gate :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: gate :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: gate :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: gate :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: gate :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { publisher , component , component_change } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub name : String , pub version : String , pub branch : String , pub transforms : :: prisma_client_rust :: serde_json :: Value , pub publisher_id : String , $ (pub $ field : crate :: prisma :: gate :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (version) , stringify ! (branch) , stringify ! (transforms) , stringify ! (publisher_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: gate :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: gate :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: gate :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: gate :: version :: NAME , & self . version) ? ; state . serialize_field (crate :: prisma :: gate :: branch :: NAME , & self . branch) ? ; state . serialize_field (crate :: prisma :: gate :: transforms :: NAME , & self . transforms) ? ; state . serialize_field (crate :: prisma :: gate :: publisher_id :: NAME , & self . publisher_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name , version , branch , transforms , publisher_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: gate :: $ field :: NAME) , + , crate :: prisma :: gate :: id :: NAME , crate :: prisma :: gate :: name :: NAME , crate :: prisma :: gate :: version :: NAME , crate :: prisma :: gate :: branch :: NAME , crate :: prisma :: gate :: transforms :: NAME , crate :: prisma :: gate :: publisher_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: gate :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: gate :: id :: NAME => Ok (Field :: id) , crate :: prisma :: gate :: name :: NAME => Ok (Field :: name) , crate :: prisma :: gate :: version :: NAME => Ok (Field :: version) , crate :: prisma :: gate :: branch :: NAME => Ok (Field :: branch) , crate :: prisma :: gate :: transforms :: NAME => Ok (Field :: transforms) , crate :: prisma :: gate :: publisher_id :: NAME => Ok (Field :: publisher_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; let mut version = None ; let mut branch = None ; let mut transforms = None ; let mut publisher_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: gate :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: gate :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: version => { if version . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: gate :: version :: NAME)) ; } version = Some (map . next_value () ?) ; } Field :: branch => { if branch . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: gate :: branch :: NAME)) ; } branch = Some (map . next_value () ?) ; } Field :: transforms => { if transforms . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: gate :: transforms :: NAME)) ; } transforms = Some (map . next_value () ?) ; } Field :: publisher_id => { if publisher_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: gate :: publisher_id :: NAME)) ; } publisher_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: gate :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: gate :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: gate :: id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: gate :: name :: NAME)) ? ; let version = version . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: gate :: version :: NAME)) ? ; let branch = branch . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: gate :: branch :: NAME)) ? ; let transforms = transforms . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: gate :: transforms :: NAME)) ? ; let publisher_id = publisher_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: gate :: publisher_id :: NAME)) ? ; Ok (Data { id , name , version , branch , transforms , publisher_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "version" , "branch" , "publisher" , "transforms" , "publisherId" , "Component" , "ComponentChange"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: gate :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; publisher : $ selection_mode : ident { $ ($ selections : tt) + }) => { publisher :: Data } ; (@ field_type ; publisher) => { crate :: prisma :: publisher :: Data } ; (@ field_type ; component : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < component :: Data > } ; (@ field_type ; component) => { Vec < crate :: prisma :: component :: Data > } ; (@ field_type ; component_change : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < component_change :: Data > } ; (@ field_type ; component_change) => { Vec < crate :: prisma :: component_change :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Gate" , available relations are "publisher, component, component_change")) } ; (@ field_module ; publisher : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: publisher :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; component : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: component :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; component_change : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: component_change :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; publisher $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: gate :: IncludeParam > :: into (crate :: prisma :: gate :: publisher :: Include :: $ selection_mode (crate :: prisma :: publisher :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; publisher $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: gate :: IncludeParam > :: into (crate :: prisma :: gate :: publisher :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; component $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: gate :: IncludeParam > :: into (crate :: prisma :: gate :: component :: Include :: $ selection_mode (crate :: prisma :: component :: ManyArgs :: new (crate :: prisma :: component :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: component :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; component $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: gate :: IncludeParam > :: into (crate :: prisma :: gate :: component :: Include :: Fetch (crate :: prisma :: component :: ManyArgs :: new (crate :: prisma :: component :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; component_change $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: gate :: IncludeParam > :: into (crate :: prisma :: gate :: component_change :: Include :: $ selection_mode (crate :: prisma :: component_change :: ManyArgs :: new (crate :: prisma :: component_change :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: component_change :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; component_change $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: gate :: IncludeParam > :: into (crate :: prisma :: gate :: component_change :: Include :: Fetch (crate :: prisma :: component_change :: ManyArgs :: new (crate :: prisma :: component_change :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: gate :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; version) => { "version" } ; (@ field_serde_name ; branch) => { "branch" } ; (@ field_serde_name ; publisher) => { "publisher" } ; (@ field_serde_name ; transforms) => { "transforms" } ; (@ field_serde_name ; publisher_id) => { "publisherId" } ; (@ field_serde_name ; component) => { "Component" } ; (@ field_serde_name ; component_change) => { "ComponentChange" } ; }
    pub use _include_gate as include;
    pub enum IncludeParam {
        Id(id::Include),
        Name(name::Include),
        Version(version::Include),
        Branch(branch::Include),
        Publisher(publisher::Include),
        Transforms(transforms::Include),
        PublisherId(publisher_id::Include),
        Component(component::Include),
        ComponentChange(component_change::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Version(data) => data.to_selection(),
                Self::Branch(data) => data.to_selection(),
                Self::Publisher(data) => data.to_selection(),
                Self::Transforms(data) => data.to_selection(),
                Self::PublisherId(data) => data.to_selection(),
                Self::Component(data) => data.to_selection(),
                Self::ComponentChange(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_gate { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: gate struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "name")] pub name : String , # [serde (rename = "version")] pub version : String , # [serde (rename = "branch")] pub branch : String , # [serde (rename = "transforms")] pub transforms : :: prisma_client_rust :: serde_json :: Value , # [serde (rename = "publisherId")] pub publisher_id : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_gate as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "version")]
        pub version: String,
        #[serde(rename = "branch")]
        pub branch: String,
        #[serde(rename = "publisher")]
        pub publisher: Option<Box<super::publisher::Data>>,
        #[serde(rename = "transforms")]
        pub transforms: ::prisma_client_rust::serde_json::Value,
        #[serde(rename = "publisherId")]
        pub publisher_id: String,
        #[serde(rename = "Component")]
        pub component: Option<Vec<super::component::Data>>,
        #[serde(rename = "ComponentChange")]
        pub component_change: Option<Vec<super::component_change::Data>>,
    }
    impl Data {
        pub fn publisher(
            &self,
        ) -> Result<&super::publisher::Data, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.publisher
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(publisher),
                ))
                .map(|v| v.as_ref())
        }
        pub fn component(
            &self,
        ) -> Result<&Vec<super::component::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.component
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(component),
                ))
        }
        pub fn component_change(
            &self,
        ) -> Result<
            &Vec<super::component_change::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.component_change.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(component_change)),
            )
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Publisher(super::publisher::UniqueArgs),
        Component(super::component::ManyArgs),
        ComponentChange(super::component_change::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Publisher(args) => {
                    let mut selections = < super :: publisher :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(publisher::NAME, None, [], selections)
                }
                Self::Component(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: component :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        component::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::ComponentChange(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: component_change :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        component_change::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetName(String),
        SetVersion(String),
        SetBranch(String),
        ConnectPublisher(super::publisher::UniqueWhereParam),
        SetTransforms(::prisma_client_rust::serde_json::Value),
        SetPublisherId(String),
        ConnectComponent(Vec<super::component::UniqueWhereParam>),
        DisconnectComponent(Vec<super::component::UniqueWhereParam>),
        SetComponent(Vec<super::component::UniqueWhereParam>),
        ConnectComponentChange(Vec<super::component_change::UniqueWhereParam>),
        DisconnectComponentChange(Vec<super::component_change::UniqueWhereParam>),
        SetComponentChange(Vec<super::component_change::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetName(value) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetVersion(value) => (
                    version::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetBranch(value) => (
                    branch::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectPublisher(where_param) => (
                    publisher::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::publisher::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetTransforms(value) => (
                    transforms::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Json(
                        ::prisma_client_rust::serde_json::to_string(&value).unwrap(),
                    ),
                ),
                SetParam::SetPublisherId(value) => (
                    publisher_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectComponent(where_params) => (
                    component::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::component::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectComponent(where_params) => (
                    component::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::component::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetComponent(where_params) => (
                    component::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::component::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectComponentChange(where_params) => (
                    component_change::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::component_change::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectComponentChange(where_params) => (
                    component_change::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::component_change::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetComponentChange(where_params) => (
                    component_change::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::component_change::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(String),
        Name(String),
        Version(String),
        Branch(String),
        Transforms(::prisma_client_rust::serde_json::Value),
        PublisherId(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Name(value) => Self::SetName(value),
                UncheckedSetParam::Version(value) => Self::SetVersion(value),
                UncheckedSetParam::Branch(value) => Self::SetBranch(value),
                UncheckedSetParam::Transforms(value) => Self::SetTransforms(value),
                UncheckedSetParam::PublisherId(value) => Self::SetPublisherId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        Version(::prisma_client_rust::Direction),
        Branch(::prisma_client_rust::Direction),
        Transforms(::prisma_client_rust::Direction),
        PublisherId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Version(direction) => (
                    version::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Branch(direction) => (
                    branch::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Transforms(direction) => (
                    transforms::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::PublisherId(direction) => (
                    publisher_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        Name(_prisma::read_filters::StringFilter),
        Version(_prisma::read_filters::StringFilter),
        Branch(_prisma::read_filters::StringFilter),
        PublisherIs(Vec<super::publisher::WhereParam>),
        PublisherIsNot(Vec<super::publisher::WhereParam>),
        Transforms(_prisma::read_filters::JsonFilter),
        PublisherId(_prisma::read_filters::StringFilter),
        ComponentSome(Vec<super::component::WhereParam>),
        ComponentEvery(Vec<super::component::WhereParam>),
        ComponentNone(Vec<super::component::WhereParam>),
        ComponentChangeSome(Vec<super::component_change::WhereParam>),
        ComponentChangeEvery(Vec<super::component_change::WhereParam>),
        ComponentChangeNone(Vec<super::component_change::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::Version(value) => (version::NAME, value.into()),
                Self::Branch(value) => (branch::NAME, value.into()),
                Self::PublisherIs(where_params) => (
                    publisher::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::PublisherIsNot(where_params) => (
                    publisher::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::Transforms(value) => (transforms::NAME, value.into()),
                Self::PublisherId(value) => (publisher_id::NAME, value.into()),
                Self::ComponentSome(where_params) => (
                    component::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ComponentEvery(where_params) => (
                    component::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ComponentNone(where_params) => (
                    component::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ComponentChangeSome(where_params) => (
                    component_change::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ComponentChangeEvery(where_params) => (
                    component_change::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ComponentChangeNone(where_params) => (
                    component_change::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(name::NAME),
                ::prisma_client_rust::sel(version::NAME),
                ::prisma_client_rust::sel(branch::NAME),
                ::prisma_client_rust::sel(transforms::NAME),
                ::prisma_client_rust::sel(publisher_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            name: String,
            version: String,
            branch: String,
            publisher: super::publisher::UniqueWhereParam,
            transforms: ::prisma_client_rust::serde_json::Value,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                name::set(name),
                version::set(version),
                branch::set(branch),
                publisher::connect(publisher),
                transforms::set(transforms),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            name: String,
            version: String,
            branch: String,
            transforms: ::prisma_client_rust::serde_json::Value,
            publisher_id: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                name::set(name),
                version::set(version),
                branch::set(branch),
                transforms::set(transforms),
                publisher_id::set(publisher_id),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(
                String,
                String,
                String,
                ::prisma_client_rust::serde_json::Value,
                String,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(name, version, branch, transforms, publisher_id, mut _params)| {
                        _params.extend([
                            name::set(name),
                            version::set(version),
                            branch::set(branch),
                            transforms::set(transforms),
                            publisher_id::set(publisher_id),
                        ]);
                        _params
                    },
                )
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (name, version, branch, publisher, transforms, mut _params): (
                String,
                String,
                String,
                super::publisher::UniqueWhereParam,
                ::prisma_client_rust::serde_json::Value,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                name::set(name),
                version::set(version),
                branch::set(branch),
                publisher::connect(publisher),
                transforms::set(transforms),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod component {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "Component";
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod version {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "version";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetVersion(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Version(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Version(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Version(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Version,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Version(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Version(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod revision {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "revision";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetRevision(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Revision(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Revision(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Revision(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Revision,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Revision(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Revision(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod anitya_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "anitya_id";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetAnityaId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::AnityaId(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::AnityaId(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::AnityaId(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            AnityaId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AnityaId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AnityaId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod repology_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "repology_id";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetRepologyId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::RepologyId(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::RepologyId(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::RepologyId(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            RepologyId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::RepologyId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::RepologyId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod project_url {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "project_url";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetProjectUrl(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ProjectUrl(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ProjectUrl(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ProjectUrl(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            ProjectUrl,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ProjectUrl(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ProjectUrl(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod gate {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "gate";
        pub struct Fetch(pub gate::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<gate::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Gate(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(gate::UniqueArgs::new())
        }
        pub struct Connect(gate::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectGate(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: gate::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<gate::WhereParam>) -> WhereParam {
            WhereParam::GateIs(value)
        }
        pub fn is_not(value: Vec<gate::WhereParam>) -> WhereParam {
            WhereParam::GateIsNot(value)
        }
        pub enum Include {
            Select(Vec<gate::SelectParam>),
            Include(Vec<gate::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Gate(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <gate::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <gate::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("gate", None, [], selections)
            }
            pub fn select(nested_selections: Vec<gate::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<gate::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<gate::SelectParam>),
            Include(Vec<gate::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Gate(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <gate::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("gate", None, [], selections)
            }
            pub fn select(nested_selections: Vec<gate::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<gate::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod recipe {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "recipe";
        pub struct Set(pub ::prisma_client_rust::serde_json::Value);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetRecipe(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Recipe(v)
            }
        }
        pub fn set<T: From<Set>>(value: ::prisma_client_rust::serde_json::Value) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Recipe(direction)
        }
        pub fn equals(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Recipe(_prisma::read_filters::JsonFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::JsonFilter, Recipe, {
            fn path(_: Vec<String>) -> Path;
            fn string_contains(_: String) -> StringContains;
            fn string_starts_with(_: String) -> StringStartsWith;
            fn string_ends_with(_: String) -> StringEndsWith;
            fn array_contains(_: Option<::prisma_client_rust::serde_json::Value>) -> ArrayContains;
            fn array_starts_with(
                _: Option<::prisma_client_rust::serde_json::Value>,
            ) -> ArrayStartsWith;
            fn array_ends_with(_: Option<::prisma_client_rust::serde_json::Value>)
                -> ArrayEndsWith;
            fn lt(_: ::prisma_client_rust::serde_json::Value) -> Lt;
            fn lte(_: ::prisma_client_rust::serde_json::Value) -> Lte;
            fn gt(_: ::prisma_client_rust::serde_json::Value) -> Gt;
            fn gte(_: ::prisma_client_rust::serde_json::Value) -> Gte;
            fn not(_: ::prisma_client_rust::serde_json::Value) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Recipe(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Recipe(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod patches {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "patches";
        pub struct Set(pub Vec<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPatches(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Patches(v)
            }
        }
        pub fn set<T: From<Set>>(value: Vec<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Patches(direction)
        }
        pub fn equals(value: Vec<String>) -> WhereParam {
            WhereParam::Patches(_prisma::read_filters::StringListFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringListFilter,
            Patches,
            {
                fn has(_: Option<String>) -> Has;
                fn has_every(_: Vec<String>) -> HasEvery;
                fn has_some(_: Vec<String>) -> HasSome;
                fn is_empty(_: bool) -> IsEmpty;
            }
        );
        pub fn push(value: Vec<String>) -> SetParam {
            SetParam::PushPatches(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Patches(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Patches(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod scripts {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "scripts";
        pub struct Set(pub Vec<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetScripts(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Scripts(v)
            }
        }
        pub fn set<T: From<Set>>(value: Vec<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Scripts(direction)
        }
        pub fn equals(value: Vec<String>) -> WhereParam {
            WhereParam::Scripts(_prisma::read_filters::StringListFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringListFilter,
            Scripts,
            {
                fn has(_: Option<String>) -> Has;
                fn has_every(_: Vec<String>) -> HasEvery;
                fn has_some(_: Vec<String>) -> HasSome;
                fn is_empty(_: bool) -> IsEmpty;
            }
        );
        pub fn push(value: Vec<String>) -> SetParam {
            SetParam::PushScripts(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Scripts(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Scripts(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod archives {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "archives";
        pub struct Set(pub Vec<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetArchives(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Archives(v)
            }
        }
        pub fn set<T: From<Set>>(value: Vec<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Archives(direction)
        }
        pub fn equals(value: Vec<String>) -> WhereParam {
            WhereParam::Archives(_prisma::read_filters::StringListFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringListFilter,
            Archives,
            {
                fn has(_: Option<String>) -> Has;
                fn has_every(_: Vec<String>) -> HasEvery;
                fn has_some(_: Vec<String>) -> HasSome;
                fn is_empty(_: bool) -> IsEmpty;
            }
        );
        pub fn push(value: Vec<String>) -> SetParam {
            SetParam::PushArchives(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Archives(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Archives(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod packages {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "packages";
        pub struct Set(pub ::prisma_client_rust::serde_json::Value);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPackages(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Packages(v)
            }
        }
        pub fn set<T: From<Set>>(value: ::prisma_client_rust::serde_json::Value) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Packages(direction)
        }
        pub fn equals(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Packages(_prisma::read_filters::JsonFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::JsonFilter,
            Packages,
            {
                fn path(_: Vec<String>) -> Path;
                fn string_contains(_: String) -> StringContains;
                fn string_starts_with(_: String) -> StringStartsWith;
                fn string_ends_with(_: String) -> StringEndsWith;
                fn array_contains(
                    _: Option<::prisma_client_rust::serde_json::Value>,
                ) -> ArrayContains;
                fn array_starts_with(
                    _: Option<::prisma_client_rust::serde_json::Value>,
                ) -> ArrayStartsWith;
                fn array_ends_with(
                    _: Option<::prisma_client_rust::serde_json::Value>,
                ) -> ArrayEndsWith;
                fn lt(_: ::prisma_client_rust::serde_json::Value) -> Lt;
                fn lte(_: ::prisma_client_rust::serde_json::Value) -> Lte;
                fn gt(_: ::prisma_client_rust::serde_json::Value) -> Gt;
                fn gte(_: ::prisma_client_rust::serde_json::Value) -> Gte;
                fn not(_: ::prisma_client_rust::serde_json::Value) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Packages(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Packages(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod gate_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "gateId";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetGateId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::GateId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::GateId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::GateId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            GateId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GateId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GateId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod component_change {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "ComponentChange";
        pub struct Fetch(pub component_change::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<component_change::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: component_change::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: component_change::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::ComponentChange(v)
            }
        }
        pub fn fetch(params: Vec<component_change::WhereParam>) -> Fetch {
            Fetch(component_change::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<component_change::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectComponentChange(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<component_change::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<component_change::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectComponentChange(params)
        }
        pub fn set(params: Vec<component_change::UniqueWhereParam>) -> SetParam {
            SetParam::SetComponentChange(params)
        }
        pub fn some(value: Vec<component_change::WhereParam>) -> WhereParam {
            WhereParam::ComponentChangeSome(value)
        }
        pub fn every(value: Vec<component_change::WhereParam>) -> WhereParam {
            WhereParam::ComponentChangeEvery(value)
        }
        pub fn none(value: Vec<component_change::WhereParam>) -> WhereParam {
            WhereParam::ComponentChangeNone(value)
        }
        pub enum Include {
            Select(
                component_change::ManyArgs,
                Vec<component_change::SelectParam>,
            ),
            Include(
                component_change::ManyArgs,
                Vec<component_change::IncludeParam>,
            ),
            Fetch(component_change::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ComponentChange(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < component_change :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < component_change :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: component_change::ManyArgs,
                nested_selections: Vec<component_change::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: component_change::ManyArgs,
                nested_selections: Vec<component_change::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                component_change::ManyArgs,
                Vec<component_change::SelectParam>,
            ),
            Include(
                component_change::ManyArgs,
                Vec<component_change::IncludeParam>,
            ),
            Fetch(component_change::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ComponentChange(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < component_change :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: component_change::ManyArgs,
                nested_selections: Vec<component_change::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: component_change::ManyArgs,
                nested_selections: Vec<component_change::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod build_job {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "BuildJob";
        pub struct Fetch(pub build_job::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<build_job::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: build_job::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: build_job::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::BuildJob(v)
            }
        }
        pub fn fetch(params: Vec<build_job::WhereParam>) -> Fetch {
            Fetch(build_job::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<build_job::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBuildJob(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<build_job::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<build_job::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectBuildJob(params)
        }
        pub fn set(params: Vec<build_job::UniqueWhereParam>) -> SetParam {
            SetParam::SetBuildJob(params)
        }
        pub fn some(value: Vec<build_job::WhereParam>) -> WhereParam {
            WhereParam::BuildJobSome(value)
        }
        pub fn every(value: Vec<build_job::WhereParam>) -> WhereParam {
            WhereParam::BuildJobEvery(value)
        }
        pub fn none(value: Vec<build_job::WhereParam>) -> WhereParam {
            WhereParam::BuildJobNone(value)
        }
        pub enum Include {
            Select(build_job::ManyArgs, Vec<build_job::SelectParam>),
            Include(build_job::ManyArgs, Vec<build_job::IncludeParam>),
            Fetch(build_job::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::BuildJob(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = < build_job :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <build_job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: build_job::ManyArgs,
                nested_selections: Vec<build_job::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: build_job::ManyArgs,
                nested_selections: Vec<build_job::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(build_job::ManyArgs, Vec<build_job::SelectParam>),
            Include(build_job::ManyArgs, Vec<build_job::IncludeParam>),
            Fetch(build_job::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::BuildJob(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <build_job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: build_job::ManyArgs,
                nested_selections: Vec<build_job::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: build_job::ManyArgs,
                nested_selections: Vec<build_job::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn name_gate_id_version_revision<T: From<UniqueWhereParam>>(
        name: String,
        gate_id: String,
        version: String,
        revision: String,
    ) -> T {
        UniqueWhereParam::NameGateIdVersionRevisionEquals(name, gate_id, version, revision).into()
    }
    pub fn create(
        name: String,
        version: String,
        revision: String,
        project_url: String,
        gate: super::gate::UniqueWhereParam,
        recipe: ::prisma_client_rust::serde_json::Value,
        packages: ::prisma_client_rust::serde_json::Value,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        String,
        String,
        super::gate::UniqueWhereParam,
        ::prisma_client_rust::serde_json::Value,
        ::prisma_client_rust::serde_json::Value,
        Vec<SetParam>,
    ) {
        (
            name,
            version,
            revision,
            project_url,
            gate,
            recipe,
            packages,
            _params,
        )
    }
    pub fn create_unchecked(
        name: String,
        version: String,
        revision: String,
        project_url: String,
        recipe: ::prisma_client_rust::serde_json::Value,
        packages: ::prisma_client_rust::serde_json::Value,
        gate_id: String,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        String,
        String,
        ::prisma_client_rust::serde_json::Value,
        ::prisma_client_rust::serde_json::Value,
        String,
        Vec<SetParam>,
    ) {
        (
            name,
            version,
            revision,
            project_url,
            recipe,
            packages,
            gate_id,
            _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_component { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: component :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: component :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: component :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: component :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: component :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: component :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { name , version , revision , anitya_id , repology_id , project_url , gate , recipe , patches , scripts , archives , packages , gate_id , component_change , build_job } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: component :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: component :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: component :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: component :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["name" , "version" , "revision" , "anitya_id" , "repology_id" , "project_url" , "gate" , "recipe" , "patches" , "scripts" , "archives" , "packages" , "gateId" , "ComponentChange" , "BuildJob"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: component :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; name) => { String } ; (@ field_type ; version) => { String } ; (@ field_type ; revision) => { String } ; (@ field_type ; anitya_id) => { Option < String > } ; (@ field_type ; repology_id) => { Option < String > } ; (@ field_type ; project_url) => { String } ; (@ field_type ; gate : $ selection_mode : ident { $ ($ selections : tt) + }) => { gate :: Data } ; (@ field_type ; gate) => { crate :: prisma :: gate :: Data } ; (@ field_type ; recipe) => { :: prisma_client_rust :: serde_json :: Value } ; (@ field_type ; patches) => { Vec < String > } ; (@ field_type ; scripts) => { Vec < String > } ; (@ field_type ; archives) => { Vec < String > } ; (@ field_type ; packages) => { :: prisma_client_rust :: serde_json :: Value } ; (@ field_type ; gate_id) => { String } ; (@ field_type ; component_change : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < component_change :: Data > } ; (@ field_type ; component_change) => { Vec < crate :: prisma :: component_change :: Data > } ; (@ field_type ; build_job : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < build_job :: Data > } ; (@ field_type ; build_job) => { Vec < crate :: prisma :: build_job :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Component" , available relations are "name, version, revision, anitya_id, repology_id, project_url, gate, recipe, patches, scripts, archives, packages, gate_id, component_change, build_job")) } ; (@ field_module ; gate : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: gate :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; component_change : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: component_change :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; build_job : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: build_job :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: component :: SelectParam > :: into (crate :: prisma :: component :: name :: Select) } ; (@ selection_field_to_selection_param ; version) => { Into :: < crate :: prisma :: component :: SelectParam > :: into (crate :: prisma :: component :: version :: Select) } ; (@ selection_field_to_selection_param ; revision) => { Into :: < crate :: prisma :: component :: SelectParam > :: into (crate :: prisma :: component :: revision :: Select) } ; (@ selection_field_to_selection_param ; anitya_id) => { Into :: < crate :: prisma :: component :: SelectParam > :: into (crate :: prisma :: component :: anitya_id :: Select) } ; (@ selection_field_to_selection_param ; repology_id) => { Into :: < crate :: prisma :: component :: SelectParam > :: into (crate :: prisma :: component :: repology_id :: Select) } ; (@ selection_field_to_selection_param ; project_url) => { Into :: < crate :: prisma :: component :: SelectParam > :: into (crate :: prisma :: component :: project_url :: Select) } ; (@ selection_field_to_selection_param ; gate $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: component :: SelectParam > :: into (crate :: prisma :: component :: gate :: Select :: $ selection_mode (crate :: prisma :: gate :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; gate $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: component :: SelectParam > :: into (crate :: prisma :: component :: gate :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; recipe) => { Into :: < crate :: prisma :: component :: SelectParam > :: into (crate :: prisma :: component :: recipe :: Select) } ; (@ selection_field_to_selection_param ; patches) => { Into :: < crate :: prisma :: component :: SelectParam > :: into (crate :: prisma :: component :: patches :: Select) } ; (@ selection_field_to_selection_param ; scripts) => { Into :: < crate :: prisma :: component :: SelectParam > :: into (crate :: prisma :: component :: scripts :: Select) } ; (@ selection_field_to_selection_param ; archives) => { Into :: < crate :: prisma :: component :: SelectParam > :: into (crate :: prisma :: component :: archives :: Select) } ; (@ selection_field_to_selection_param ; packages) => { Into :: < crate :: prisma :: component :: SelectParam > :: into (crate :: prisma :: component :: packages :: Select) } ; (@ selection_field_to_selection_param ; gate_id) => { Into :: < crate :: prisma :: component :: SelectParam > :: into (crate :: prisma :: component :: gate_id :: Select) } ; (@ selection_field_to_selection_param ; component_change $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: component :: SelectParam > :: into (crate :: prisma :: component :: component_change :: Select :: $ selection_mode (crate :: prisma :: component_change :: ManyArgs :: new (crate :: prisma :: component_change :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: component_change :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; component_change $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: component :: SelectParam > :: into (crate :: prisma :: component :: component_change :: Select :: Fetch (crate :: prisma :: component_change :: ManyArgs :: new (crate :: prisma :: component_change :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; build_job $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: component :: SelectParam > :: into (crate :: prisma :: component :: build_job :: Select :: $ selection_mode (crate :: prisma :: build_job :: ManyArgs :: new (crate :: prisma :: build_job :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: build_job :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; build_job $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: component :: SelectParam > :: into (crate :: prisma :: component :: build_job :: Select :: Fetch (crate :: prisma :: build_job :: ManyArgs :: new (crate :: prisma :: build_job :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: component :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; version) => { "version" } ; (@ field_serde_name ; revision) => { "revision" } ; (@ field_serde_name ; anitya_id) => { "anitya_id" } ; (@ field_serde_name ; repology_id) => { "repology_id" } ; (@ field_serde_name ; project_url) => { "project_url" } ; (@ field_serde_name ; gate) => { "gate" } ; (@ field_serde_name ; recipe) => { "recipe" } ; (@ field_serde_name ; patches) => { "patches" } ; (@ field_serde_name ; scripts) => { "scripts" } ; (@ field_serde_name ; archives) => { "archives" } ; (@ field_serde_name ; packages) => { "packages" } ; (@ field_serde_name ; gate_id) => { "gateId" } ; (@ field_serde_name ; component_change) => { "ComponentChange" } ; (@ field_serde_name ; build_job) => { "BuildJob" } ; }
    pub use _select_component as select;
    pub enum SelectParam {
        Name(name::Select),
        Version(version::Select),
        Revision(revision::Select),
        AnityaId(anitya_id::Select),
        RepologyId(repology_id::Select),
        ProjectUrl(project_url::Select),
        Gate(gate::Select),
        Recipe(recipe::Select),
        Patches(patches::Select),
        Scripts(scripts::Select),
        Archives(archives::Select),
        Packages(packages::Select),
        GateId(gate_id::Select),
        ComponentChange(component_change::Select),
        BuildJob(build_job::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Name(data) => data.to_selection(),
                Self::Version(data) => data.to_selection(),
                Self::Revision(data) => data.to_selection(),
                Self::AnityaId(data) => data.to_selection(),
                Self::RepologyId(data) => data.to_selection(),
                Self::ProjectUrl(data) => data.to_selection(),
                Self::Gate(data) => data.to_selection(),
                Self::Recipe(data) => data.to_selection(),
                Self::Patches(data) => data.to_selection(),
                Self::Scripts(data) => data.to_selection(),
                Self::Archives(data) => data.to_selection(),
                Self::Packages(data) => data.to_selection(),
                Self::GateId(data) => data.to_selection(),
                Self::ComponentChange(data) => data.to_selection(),
                Self::BuildJob(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_component { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: component :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: component :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: component :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: component :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: component :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: component :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: component :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: component :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { gate , component_change , build_job } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub name : String , pub version : String , pub revision : String , pub anitya_id : Option < String > , pub repology_id : Option < String > , pub project_url : String , pub recipe : :: prisma_client_rust :: serde_json :: Value , pub patches : Vec < String > , pub scripts : Vec < String > , pub archives : Vec < String > , pub packages : :: prisma_client_rust :: serde_json :: Value , pub gate_id : String , $ (pub $ field : crate :: prisma :: component :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (name) , stringify ! (version) , stringify ! (revision) , stringify ! (anitya_id) , stringify ! (repology_id) , stringify ! (project_url) , stringify ! (recipe) , stringify ! (patches) , stringify ! (scripts) , stringify ! (archives) , stringify ! (packages) , stringify ! (gate_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: component :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: component :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: component :: version :: NAME , & self . version) ? ; state . serialize_field (crate :: prisma :: component :: revision :: NAME , & self . revision) ? ; state . serialize_field (crate :: prisma :: component :: anitya_id :: NAME , & self . anitya_id) ? ; state . serialize_field (crate :: prisma :: component :: repology_id :: NAME , & self . repology_id) ? ; state . serialize_field (crate :: prisma :: component :: project_url :: NAME , & self . project_url) ? ; state . serialize_field (crate :: prisma :: component :: recipe :: NAME , & self . recipe) ? ; state . serialize_field (crate :: prisma :: component :: patches :: NAME , & self . patches) ? ; state . serialize_field (crate :: prisma :: component :: scripts :: NAME , & self . scripts) ? ; state . serialize_field (crate :: prisma :: component :: archives :: NAME , & self . archives) ? ; state . serialize_field (crate :: prisma :: component :: packages :: NAME , & self . packages) ? ; state . serialize_field (crate :: prisma :: component :: gate_id :: NAME , & self . gate_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , name , version , revision , anitya_id , repology_id , project_url , recipe , patches , scripts , archives , packages , gate_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: component :: $ field :: NAME) , + , crate :: prisma :: component :: name :: NAME , crate :: prisma :: component :: version :: NAME , crate :: prisma :: component :: revision :: NAME , crate :: prisma :: component :: anitya_id :: NAME , crate :: prisma :: component :: repology_id :: NAME , crate :: prisma :: component :: project_url :: NAME , crate :: prisma :: component :: recipe :: NAME , crate :: prisma :: component :: patches :: NAME , crate :: prisma :: component :: scripts :: NAME , crate :: prisma :: component :: archives :: NAME , crate :: prisma :: component :: packages :: NAME , crate :: prisma :: component :: gate_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: component :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: component :: name :: NAME => Ok (Field :: name) , crate :: prisma :: component :: version :: NAME => Ok (Field :: version) , crate :: prisma :: component :: revision :: NAME => Ok (Field :: revision) , crate :: prisma :: component :: anitya_id :: NAME => Ok (Field :: anitya_id) , crate :: prisma :: component :: repology_id :: NAME => Ok (Field :: repology_id) , crate :: prisma :: component :: project_url :: NAME => Ok (Field :: project_url) , crate :: prisma :: component :: recipe :: NAME => Ok (Field :: recipe) , crate :: prisma :: component :: patches :: NAME => Ok (Field :: patches) , crate :: prisma :: component :: scripts :: NAME => Ok (Field :: scripts) , crate :: prisma :: component :: archives :: NAME => Ok (Field :: archives) , crate :: prisma :: component :: packages :: NAME => Ok (Field :: packages) , crate :: prisma :: component :: gate_id :: NAME => Ok (Field :: gate_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut name = None ; let mut version = None ; let mut revision = None ; let mut anitya_id = None ; let mut repology_id = None ; let mut project_url = None ; let mut recipe = None ; let mut patches = None ; let mut scripts = None ; let mut archives = None ; let mut packages = None ; let mut gate_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: version => { if version . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component :: version :: NAME)) ; } version = Some (map . next_value () ?) ; } Field :: revision => { if revision . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component :: revision :: NAME)) ; } revision = Some (map . next_value () ?) ; } Field :: anitya_id => { if anitya_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component :: anitya_id :: NAME)) ; } anitya_id = Some (map . next_value () ?) ; } Field :: repology_id => { if repology_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component :: repology_id :: NAME)) ; } repology_id = Some (map . next_value () ?) ; } Field :: project_url => { if project_url . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component :: project_url :: NAME)) ; } project_url = Some (map . next_value () ?) ; } Field :: recipe => { if recipe . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component :: recipe :: NAME)) ; } recipe = Some (map . next_value () ?) ; } Field :: patches => { if patches . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component :: patches :: NAME)) ; } patches = Some (map . next_value () ?) ; } Field :: scripts => { if scripts . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component :: scripts :: NAME)) ; } scripts = Some (map . next_value () ?) ; } Field :: archives => { if archives . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component :: archives :: NAME)) ; } archives = Some (map . next_value () ?) ; } Field :: packages => { if packages . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component :: packages :: NAME)) ; } packages = Some (map . next_value () ?) ; } Field :: gate_id => { if gate_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component :: gate_id :: NAME)) ; } gate_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component :: $ field :: NAME)) ? ;) * let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component :: name :: NAME)) ? ; let version = version . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component :: version :: NAME)) ? ; let revision = revision . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component :: revision :: NAME)) ? ; let anitya_id = anitya_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component :: anitya_id :: NAME)) ? ; let repology_id = repology_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component :: repology_id :: NAME)) ? ; let project_url = project_url . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component :: project_url :: NAME)) ? ; let recipe = recipe . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component :: recipe :: NAME)) ? ; let patches = patches . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component :: patches :: NAME)) ? ; let scripts = scripts . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component :: scripts :: NAME)) ? ; let archives = archives . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component :: archives :: NAME)) ? ; let packages = packages . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component :: packages :: NAME)) ? ; let gate_id = gate_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component :: gate_id :: NAME)) ? ; Ok (Data { name , version , revision , anitya_id , repology_id , project_url , recipe , patches , scripts , archives , packages , gate_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["name" , "version" , "revision" , "anitya_id" , "repology_id" , "project_url" , "gate" , "recipe" , "patches" , "scripts" , "archives" , "packages" , "gateId" , "ComponentChange" , "BuildJob"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: component :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; gate : $ selection_mode : ident { $ ($ selections : tt) + }) => { gate :: Data } ; (@ field_type ; gate) => { crate :: prisma :: gate :: Data } ; (@ field_type ; component_change : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < component_change :: Data > } ; (@ field_type ; component_change) => { Vec < crate :: prisma :: component_change :: Data > } ; (@ field_type ; build_job : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < build_job :: Data > } ; (@ field_type ; build_job) => { Vec < crate :: prisma :: build_job :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Component" , available relations are "gate, component_change, build_job")) } ; (@ field_module ; gate : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: gate :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; component_change : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: component_change :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; build_job : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: build_job :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; gate $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: component :: IncludeParam > :: into (crate :: prisma :: component :: gate :: Include :: $ selection_mode (crate :: prisma :: gate :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; gate $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: component :: IncludeParam > :: into (crate :: prisma :: component :: gate :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; component_change $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: component :: IncludeParam > :: into (crate :: prisma :: component :: component_change :: Include :: $ selection_mode (crate :: prisma :: component_change :: ManyArgs :: new (crate :: prisma :: component_change :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: component_change :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; component_change $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: component :: IncludeParam > :: into (crate :: prisma :: component :: component_change :: Include :: Fetch (crate :: prisma :: component_change :: ManyArgs :: new (crate :: prisma :: component_change :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; build_job $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: component :: IncludeParam > :: into (crate :: prisma :: component :: build_job :: Include :: $ selection_mode (crate :: prisma :: build_job :: ManyArgs :: new (crate :: prisma :: build_job :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: build_job :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; build_job $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: component :: IncludeParam > :: into (crate :: prisma :: component :: build_job :: Include :: Fetch (crate :: prisma :: build_job :: ManyArgs :: new (crate :: prisma :: build_job :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: component :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; version) => { "version" } ; (@ field_serde_name ; revision) => { "revision" } ; (@ field_serde_name ; anitya_id) => { "anitya_id" } ; (@ field_serde_name ; repology_id) => { "repology_id" } ; (@ field_serde_name ; project_url) => { "project_url" } ; (@ field_serde_name ; gate) => { "gate" } ; (@ field_serde_name ; recipe) => { "recipe" } ; (@ field_serde_name ; patches) => { "patches" } ; (@ field_serde_name ; scripts) => { "scripts" } ; (@ field_serde_name ; archives) => { "archives" } ; (@ field_serde_name ; packages) => { "packages" } ; (@ field_serde_name ; gate_id) => { "gateId" } ; (@ field_serde_name ; component_change) => { "ComponentChange" } ; (@ field_serde_name ; build_job) => { "BuildJob" } ; }
    pub use _include_component as include;
    pub enum IncludeParam {
        Name(name::Include),
        Version(version::Include),
        Revision(revision::Include),
        AnityaId(anitya_id::Include),
        RepologyId(repology_id::Include),
        ProjectUrl(project_url::Include),
        Gate(gate::Include),
        Recipe(recipe::Include),
        Patches(patches::Include),
        Scripts(scripts::Include),
        Archives(archives::Include),
        Packages(packages::Include),
        GateId(gate_id::Include),
        ComponentChange(component_change::Include),
        BuildJob(build_job::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Name(data) => data.to_selection(),
                Self::Version(data) => data.to_selection(),
                Self::Revision(data) => data.to_selection(),
                Self::AnityaId(data) => data.to_selection(),
                Self::RepologyId(data) => data.to_selection(),
                Self::ProjectUrl(data) => data.to_selection(),
                Self::Gate(data) => data.to_selection(),
                Self::Recipe(data) => data.to_selection(),
                Self::Patches(data) => data.to_selection(),
                Self::Scripts(data) => data.to_selection(),
                Self::Archives(data) => data.to_selection(),
                Self::Packages(data) => data.to_selection(),
                Self::GateId(data) => data.to_selection(),
                Self::ComponentChange(data) => data.to_selection(),
                Self::BuildJob(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_component { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: component struct $ struct_name { # [serde (rename = "name")] pub name : String , # [serde (rename = "version")] pub version : String , # [serde (rename = "revision")] pub revision : String , # [serde (rename = "anitya_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub anitya_id : Option < String > , # [serde (rename = "repology_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub repology_id : Option < String > , # [serde (rename = "project_url")] pub project_url : String , # [serde (rename = "recipe")] pub recipe : :: prisma_client_rust :: serde_json :: Value , # [serde (rename = "patches")] pub patches : Vec < String > , # [serde (rename = "scripts")] pub scripts : Vec < String > , # [serde (rename = "archives")] pub archives : Vec < String > , # [serde (rename = "packages")] pub packages : :: prisma_client_rust :: serde_json :: Value , # [serde (rename = "gateId")] pub gate_id : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_component as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "version")]
        pub version: String,
        #[serde(rename = "revision")]
        pub revision: String,
        #[serde(rename = "anitya_id")]
        pub anitya_id: Option<String>,
        #[serde(rename = "repology_id")]
        pub repology_id: Option<String>,
        #[serde(rename = "project_url")]
        pub project_url: String,
        #[serde(rename = "gate")]
        pub gate: Option<Box<super::gate::Data>>,
        #[serde(rename = "recipe")]
        pub recipe: ::prisma_client_rust::serde_json::Value,
        #[serde(rename = "patches")]
        pub patches: Vec<String>,
        #[serde(rename = "scripts")]
        pub scripts: Vec<String>,
        #[serde(rename = "archives")]
        pub archives: Vec<String>,
        #[serde(rename = "packages")]
        pub packages: ::prisma_client_rust::serde_json::Value,
        #[serde(rename = "gateId")]
        pub gate_id: String,
        #[serde(rename = "ComponentChange")]
        pub component_change: Option<Vec<super::component_change::Data>>,
        #[serde(rename = "BuildJob")]
        pub build_job: Option<Vec<super::build_job::Data>>,
    }
    impl Data {
        pub fn gate(
            &self,
        ) -> Result<&super::gate::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.gate
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(gate),
                ))
                .map(|v| v.as_ref())
        }
        pub fn component_change(
            &self,
        ) -> Result<
            &Vec<super::component_change::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.component_change.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(component_change)),
            )
        }
        pub fn build_job(
            &self,
        ) -> Result<&Vec<super::build_job::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.build_job
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(build_job),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Gate(super::gate::UniqueArgs),
        ComponentChange(super::component_change::ManyArgs),
        BuildJob(super::build_job::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Gate(args) => {
                    let mut selections =
                        <super::gate::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(gate::NAME, None, [], selections)
                }
                Self::ComponentChange(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: component_change :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        component_change::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::BuildJob(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: build_job :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        build_job::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetName(String),
        SetVersion(String),
        SetRevision(String),
        SetAnityaId(Option<String>),
        SetRepologyId(Option<String>),
        SetProjectUrl(String),
        ConnectGate(super::gate::UniqueWhereParam),
        SetRecipe(::prisma_client_rust::serde_json::Value),
        SetPatches(Vec<String>),
        PushPatches(Vec<String>),
        SetScripts(Vec<String>),
        PushScripts(Vec<String>),
        SetArchives(Vec<String>),
        PushArchives(Vec<String>),
        SetPackages(::prisma_client_rust::serde_json::Value),
        SetGateId(String),
        ConnectComponentChange(Vec<super::component_change::UniqueWhereParam>),
        DisconnectComponentChange(Vec<super::component_change::UniqueWhereParam>),
        SetComponentChange(Vec<super::component_change::UniqueWhereParam>),
        ConnectBuildJob(Vec<super::build_job::UniqueWhereParam>),
        DisconnectBuildJob(Vec<super::build_job::UniqueWhereParam>),
        SetBuildJob(Vec<super::build_job::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetName(value) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetVersion(value) => (
                    version::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetRevision(value) => (
                    revision::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetAnityaId(value) => (
                    anitya_id::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetRepologyId(value) => (
                    repology_id::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetProjectUrl(value) => (
                    project_url::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectGate(where_param) => (
                    gate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::gate::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetRecipe(value) => (
                    recipe::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Json(
                        ::prisma_client_rust::serde_json::to_string(&value).unwrap(),
                    ),
                ),
                SetParam::SetPatches(value) => (
                    patches::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .collect(),
                    ),
                ),
                SetParam::PushPatches(value) => (
                    patches::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetScripts(value) => (
                    scripts::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .collect(),
                    ),
                ),
                SetParam::PushScripts(value) => (
                    scripts::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetArchives(value) => (
                    archives::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .collect(),
                    ),
                ),
                SetParam::PushArchives(value) => (
                    archives::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetPackages(value) => (
                    packages::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Json(
                        ::prisma_client_rust::serde_json::to_string(&value).unwrap(),
                    ),
                ),
                SetParam::SetGateId(value) => (
                    gate_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectComponentChange(where_params) => (
                    component_change::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::component_change::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectComponentChange(where_params) => (
                    component_change::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::component_change::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetComponentChange(where_params) => (
                    component_change::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::component_change::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectBuildJob(where_params) => (
                    build_job::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::build_job::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectBuildJob(where_params) => (
                    build_job::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::build_job::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetBuildJob(where_params) => (
                    build_job::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::build_job::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Name(String),
        Version(String),
        Revision(String),
        AnityaId(Option<String>),
        RepologyId(Option<String>),
        ProjectUrl(String),
        Recipe(::prisma_client_rust::serde_json::Value),
        Patches(Vec<String>),
        Scripts(Vec<String>),
        Archives(Vec<String>),
        Packages(::prisma_client_rust::serde_json::Value),
        GateId(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Name(value) => Self::SetName(value),
                UncheckedSetParam::Version(value) => Self::SetVersion(value),
                UncheckedSetParam::Revision(value) => Self::SetRevision(value),
                UncheckedSetParam::AnityaId(value) => Self::SetAnityaId(value),
                UncheckedSetParam::RepologyId(value) => Self::SetRepologyId(value),
                UncheckedSetParam::ProjectUrl(value) => Self::SetProjectUrl(value),
                UncheckedSetParam::Recipe(value) => Self::SetRecipe(value),
                UncheckedSetParam::Patches(value) => Self::SetPatches(value),
                UncheckedSetParam::Scripts(value) => Self::SetScripts(value),
                UncheckedSetParam::Archives(value) => Self::SetArchives(value),
                UncheckedSetParam::Packages(value) => Self::SetPackages(value),
                UncheckedSetParam::GateId(value) => Self::SetGateId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Name(::prisma_client_rust::Direction),
        Version(::prisma_client_rust::Direction),
        Revision(::prisma_client_rust::Direction),
        AnityaId(::prisma_client_rust::Direction),
        RepologyId(::prisma_client_rust::Direction),
        ProjectUrl(::prisma_client_rust::Direction),
        Recipe(::prisma_client_rust::Direction),
        Patches(::prisma_client_rust::Direction),
        Scripts(::prisma_client_rust::Direction),
        Archives(::prisma_client_rust::Direction),
        Packages(::prisma_client_rust::Direction),
        GateId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Name(direction) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Version(direction) => (
                    version::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Revision(direction) => (
                    revision::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::AnityaId(direction) => (
                    anitya_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::RepologyId(direction) => (
                    repology_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ProjectUrl(direction) => (
                    project_url::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Recipe(direction) => (
                    recipe::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Patches(direction) => (
                    patches::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Scripts(direction) => (
                    scripts::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Archives(direction) => (
                    archives::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Packages(direction) => (
                    packages::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::GateId(direction) => (
                    gate_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        NameGateIdVersionRevisionEquals(String, String, String, String),
        Name(_prisma::read_filters::StringFilter),
        Version(_prisma::read_filters::StringFilter),
        Revision(_prisma::read_filters::StringFilter),
        AnityaId(_prisma::read_filters::StringNullableFilter),
        RepologyId(_prisma::read_filters::StringNullableFilter),
        ProjectUrl(_prisma::read_filters::StringFilter),
        GateIs(Vec<super::gate::WhereParam>),
        GateIsNot(Vec<super::gate::WhereParam>),
        Recipe(_prisma::read_filters::JsonFilter),
        Patches(_prisma::read_filters::StringListFilter),
        Scripts(_prisma::read_filters::StringListFilter),
        Archives(_prisma::read_filters::StringListFilter),
        Packages(_prisma::read_filters::JsonFilter),
        GateId(_prisma::read_filters::StringFilter),
        ComponentChangeSome(Vec<super::component_change::WhereParam>),
        ComponentChangeEvery(Vec<super::component_change::WhereParam>),
        ComponentChangeNone(Vec<super::component_change::WhereParam>),
        BuildJobSome(Vec<super::build_job::WhereParam>),
        BuildJobEvery(Vec<super::build_job::WhereParam>),
        BuildJobNone(Vec<super::build_job::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::NameGateIdVersionRevisionEquals(name, gate_id, version, revision) => (
                    "name_gateId_version_revision",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            name::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::String(name),
                        ),
                        (
                            gate_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::String(gate_id),
                        ),
                        (
                            version::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::String(version),
                        ),
                        (
                            revision::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::String(revision),
                        ),
                    ]),
                ),
                Self::Name(value) => (name::NAME, value.into()),
                Self::Version(value) => (version::NAME, value.into()),
                Self::Revision(value) => (revision::NAME, value.into()),
                Self::AnityaId(value) => (anitya_id::NAME, value.into()),
                Self::RepologyId(value) => (repology_id::NAME, value.into()),
                Self::ProjectUrl(value) => (project_url::NAME, value.into()),
                Self::GateIs(where_params) => (
                    gate::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::GateIsNot(where_params) => (
                    gate::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::Recipe(value) => (recipe::NAME, value.into()),
                Self::Patches(value) => (patches::NAME, value.into()),
                Self::Scripts(value) => (scripts::NAME, value.into()),
                Self::Archives(value) => (archives::NAME, value.into()),
                Self::Packages(value) => (packages::NAME, value.into()),
                Self::GateId(value) => (gate_id::NAME, value.into()),
                Self::ComponentChangeSome(where_params) => (
                    component_change::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ComponentChangeEvery(where_params) => (
                    component_change::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ComponentChangeNone(where_params) => (
                    component_change::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BuildJobSome(where_params) => (
                    build_job::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BuildJobEvery(where_params) => (
                    build_job::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BuildJobNone(where_params) => (
                    build_job::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        NameGateIdVersionRevisionEquals(String, String, String, String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::NameGateIdVersionRevisionEquals(
                    name,
                    gate_id,
                    version,
                    revision,
                ) => Self::NameGateIdVersionRevisionEquals(name, gate_id, version, revision),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(name::NAME),
                ::prisma_client_rust::sel(version::NAME),
                ::prisma_client_rust::sel(revision::NAME),
                ::prisma_client_rust::sel(anitya_id::NAME),
                ::prisma_client_rust::sel(repology_id::NAME),
                ::prisma_client_rust::sel(project_url::NAME),
                ::prisma_client_rust::sel(recipe::NAME),
                ::prisma_client_rust::sel(patches::NAME),
                ::prisma_client_rust::sel(scripts::NAME),
                ::prisma_client_rust::sel(archives::NAME),
                ::prisma_client_rust::sel(packages::NAME),
                ::prisma_client_rust::sel(gate_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            name: String,
            version: String,
            revision: String,
            project_url: String,
            gate: super::gate::UniqueWhereParam,
            recipe: ::prisma_client_rust::serde_json::Value,
            packages: ::prisma_client_rust::serde_json::Value,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                name::set(name),
                version::set(version),
                revision::set(revision),
                project_url::set(project_url),
                gate::connect(gate),
                recipe::set(recipe),
                packages::set(packages),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            name: String,
            version: String,
            revision: String,
            project_url: String,
            recipe: ::prisma_client_rust::serde_json::Value,
            packages: ::prisma_client_rust::serde_json::Value,
            gate_id: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                name::set(name),
                version::set(version),
                revision::set(revision),
                project_url::set(project_url),
                recipe::set(recipe),
                packages::set(packages),
                gate_id::set(gate_id),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(
                String,
                String,
                String,
                String,
                ::prisma_client_rust::serde_json::Value,
                ::prisma_client_rust::serde_json::Value,
                String,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(
                        name,
                        version,
                        revision,
                        project_url,
                        recipe,
                        packages,
                        gate_id,
                        mut _params,
                    )| {
                        _params.extend([
                            name::set(name),
                            version::set(version),
                            revision::set(revision),
                            project_url::set(project_url),
                            recipe::set(recipe),
                            packages::set(packages),
                            gate_id::set(gate_id),
                        ]);
                        _params
                    },
                )
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (name, version, revision, project_url, gate, recipe, packages, mut _params): (
                String,
                String,
                String,
                String,
                super::gate::UniqueWhereParam,
                ::prisma_client_rust::serde_json::Value,
                ::prisma_client_rust::serde_json::Value,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                name::set(name),
                version::set(version),
                revision::set(revision),
                project_url::set(project_url),
                gate::connect(gate),
                recipe::set(recipe),
                packages::set(packages),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod component_change {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "ComponentChange";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod kind {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "kind";
        pub struct Set(pub self::ComponentChangeKind);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetKind(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Kind(v)
            }
        }
        pub fn set<T: From<Set>>(value: self::ComponentChangeKind) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Kind(direction)
        }
        pub fn equals(value: self::ComponentChangeKind) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::ComponentChangeKindFilter::Equals(
                value,
            ))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::ComponentChangeKindFilter,
            Kind,
            {
                fn in_vec(_: Vec<super::super::ComponentChangeKind>) -> InVec;
                fn not_in_vec(_: Vec<super::super::ComponentChangeKind>) -> NotInVec;
                fn not(_: super::super::ComponentChangeKind) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Kind(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Kind(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod diff {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "diff";
        pub struct Set(pub ::prisma_client_rust::serde_json::Value);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDiff(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Diff(v)
            }
        }
        pub fn set<T: From<Set>>(value: ::prisma_client_rust::serde_json::Value) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Diff(direction)
        }
        pub fn equals(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Diff(_prisma::read_filters::JsonFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::JsonFilter, Diff, {
            fn path(_: Vec<String>) -> Path;
            fn string_contains(_: String) -> StringContains;
            fn string_starts_with(_: String) -> StringStartsWith;
            fn string_ends_with(_: String) -> StringEndsWith;
            fn array_contains(_: Option<::prisma_client_rust::serde_json::Value>) -> ArrayContains;
            fn array_starts_with(
                _: Option<::prisma_client_rust::serde_json::Value>,
            ) -> ArrayStartsWith;
            fn array_ends_with(_: Option<::prisma_client_rust::serde_json::Value>)
                -> ArrayEndsWith;
            fn lt(_: ::prisma_client_rust::serde_json::Value) -> Lt;
            fn lte(_: ::prisma_client_rust::serde_json::Value) -> Lte;
            fn gt(_: ::prisma_client_rust::serde_json::Value) -> Gt;
            fn gte(_: ::prisma_client_rust::serde_json::Value) -> Gte;
            fn not(_: ::prisma_client_rust::serde_json::Value) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Diff(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Diff(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod component {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "component";
        pub struct Fetch(pub component::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<component::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Component(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(component::UniqueArgs::new())
        }
        pub struct Connect(component::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectComponent(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: component::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectComponent
        }
        pub fn is_null() -> WhereParam {
            WhereParam::ComponentIsNull
        }
        pub fn is(value: Vec<component::WhereParam>) -> WhereParam {
            WhereParam::ComponentIs(value)
        }
        pub fn is_not(value: Vec<component::WhereParam>) -> WhereParam {
            WhereParam::ComponentIsNot(value)
        }
        pub enum Include {
            Select(Vec<component::SelectParam>),
            Include(Vec<component::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Component(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = < component :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <component::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("component", None, [], selections)
            }
            pub fn select(nested_selections: Vec<component::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<component::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<component::SelectParam>),
            Include(Vec<component::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Component(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <component::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("component", None, [], selections)
            }
            pub fn select(nested_selections: Vec<component::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<component::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod recipe {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "recipe";
        pub struct Set(pub ::prisma_client_rust::serde_json::Value);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetRecipe(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Recipe(v)
            }
        }
        pub fn set<T: From<Set>>(value: ::prisma_client_rust::serde_json::Value) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Recipe(direction)
        }
        pub fn equals(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Recipe(_prisma::read_filters::JsonFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::JsonFilter, Recipe, {
            fn path(_: Vec<String>) -> Path;
            fn string_contains(_: String) -> StringContains;
            fn string_starts_with(_: String) -> StringStartsWith;
            fn string_ends_with(_: String) -> StringEndsWith;
            fn array_contains(_: Option<::prisma_client_rust::serde_json::Value>) -> ArrayContains;
            fn array_starts_with(
                _: Option<::prisma_client_rust::serde_json::Value>,
            ) -> ArrayStartsWith;
            fn array_ends_with(_: Option<::prisma_client_rust::serde_json::Value>)
                -> ArrayEndsWith;
            fn lt(_: ::prisma_client_rust::serde_json::Value) -> Lt;
            fn lte(_: ::prisma_client_rust::serde_json::Value) -> Lte;
            fn gt(_: ::prisma_client_rust::serde_json::Value) -> Gt;
            fn gte(_: ::prisma_client_rust::serde_json::Value) -> Gte;
            fn not(_: ::prisma_client_rust::serde_json::Value) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Recipe(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Recipe(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod version {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "version";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetVersion(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Version(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Version(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Version(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Version,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Version(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Version(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod revision {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "revision";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetRevision(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Revision(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Revision(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Revision(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Revision,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Revision(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Revision(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod gate {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "gate";
        pub struct Fetch(pub gate::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<gate::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Gate(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(gate::UniqueArgs::new())
        }
        pub struct Connect(gate::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectGate(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: gate::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectGate
        }
        pub fn is_null() -> WhereParam {
            WhereParam::GateIsNull
        }
        pub fn is(value: Vec<gate::WhereParam>) -> WhereParam {
            WhereParam::GateIs(value)
        }
        pub fn is_not(value: Vec<gate::WhereParam>) -> WhereParam {
            WhereParam::GateIsNot(value)
        }
        pub enum Include {
            Select(Vec<gate::SelectParam>),
            Include(Vec<gate::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Gate(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <gate::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <gate::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("gate", None, [], selections)
            }
            pub fn select(nested_selections: Vec<gate::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<gate::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<gate::SelectParam>),
            Include(Vec<gate::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Gate(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <gate::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("gate", None, [], selections)
            }
            pub fn select(nested_selections: Vec<gate::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<gate::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod patches {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "patches";
        pub struct Set(pub Vec<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPatches(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Patches(v)
            }
        }
        pub fn set<T: From<Set>>(value: Vec<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Patches(direction)
        }
        pub fn equals(value: Vec<String>) -> WhereParam {
            WhereParam::Patches(_prisma::read_filters::StringListFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringListFilter,
            Patches,
            {
                fn has(_: Option<String>) -> Has;
                fn has_every(_: Vec<String>) -> HasEvery;
                fn has_some(_: Vec<String>) -> HasSome;
                fn is_empty(_: bool) -> IsEmpty;
            }
        );
        pub fn push(value: Vec<String>) -> SetParam {
            SetParam::PushPatches(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Patches(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Patches(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod scripts {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "scripts";
        pub struct Set(pub Vec<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetScripts(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Scripts(v)
            }
        }
        pub fn set<T: From<Set>>(value: Vec<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Scripts(direction)
        }
        pub fn equals(value: Vec<String>) -> WhereParam {
            WhereParam::Scripts(_prisma::read_filters::StringListFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringListFilter,
            Scripts,
            {
                fn has(_: Option<String>) -> Has;
                fn has_every(_: Vec<String>) -> HasEvery;
                fn has_some(_: Vec<String>) -> HasSome;
                fn is_empty(_: bool) -> IsEmpty;
            }
        );
        pub fn push(value: Vec<String>) -> SetParam {
            SetParam::PushScripts(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Scripts(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Scripts(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod archives {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "archives";
        pub struct Set(pub Vec<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetArchives(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Archives(v)
            }
        }
        pub fn set<T: From<Set>>(value: Vec<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Archives(direction)
        }
        pub fn equals(value: Vec<String>) -> WhereParam {
            WhereParam::Archives(_prisma::read_filters::StringListFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringListFilter,
            Archives,
            {
                fn has(_: Option<String>) -> Has;
                fn has_every(_: Vec<String>) -> HasEvery;
                fn has_some(_: Vec<String>) -> HasSome;
                fn is_empty(_: bool) -> IsEmpty;
            }
        );
        pub fn push(value: Vec<String>) -> SetParam {
            SetParam::PushArchives(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Archives(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Archives(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod change_request {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "change_request";
        pub struct Fetch(pub change_request::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<change_request::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::ChangeRequest(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(change_request::UniqueArgs::new())
        }
        pub struct Connect(change_request::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectChangeRequest(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: change_request::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<change_request::WhereParam>) -> WhereParam {
            WhereParam::ChangeRequestIs(value)
        }
        pub fn is_not(value: Vec<change_request::WhereParam>) -> WhereParam {
            WhereParam::ChangeRequestIsNot(value)
        }
        pub enum Include {
            Select(Vec<change_request::SelectParam>),
            Include(Vec<change_request::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ChangeRequest(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = < change_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < change_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("change_request", None, [], selections)
            }
            pub fn select(nested_selections: Vec<change_request::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<change_request::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<change_request::SelectParam>),
            Include(Vec<change_request::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ChangeRequest(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < change_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("change_request", None, [], selections)
            }
            pub fn select(nested_selections: Vec<change_request::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<change_request::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod component_name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "componentName";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetComponentName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ComponentName(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ComponentName(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::ComponentName(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            ComponentName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ComponentName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ComponentName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod component_version {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "componentVersion";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetComponentVersion(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ComponentVersion(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ComponentVersion(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::ComponentVersion(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            ComponentVersion,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ComponentVersion(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ComponentVersion(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod component_revision {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "componentRevision";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetComponentRevision(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ComponentRevision(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ComponentRevision(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::ComponentRevision(_prisma::read_filters::StringNullableFilter::Equals(
                value,
            ))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            ComponentRevision,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ComponentRevision(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ComponentRevision(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod gate_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "gateId";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetGateId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::GateId(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::GateId(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::GateId(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            GateId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GateId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GateId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod change_request_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "changeRequestId";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetChangeRequestId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ChangeRequestId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ChangeRequestId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ChangeRequestId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            ChangeRequestId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ChangeRequestId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ChangeRequestId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub fn create(
        kind: super::ComponentChangeKind,
        diff: ::prisma_client_rust::serde_json::Value,
        recipe: ::prisma_client_rust::serde_json::Value,
        version: String,
        revision: String,
        change_request: super::change_request::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        super::ComponentChangeKind,
        ::prisma_client_rust::serde_json::Value,
        ::prisma_client_rust::serde_json::Value,
        String,
        String,
        super::change_request::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (
            kind,
            diff,
            recipe,
            version,
            revision,
            change_request,
            _params,
        )
    }
    pub fn create_unchecked(
        kind: super::ComponentChangeKind,
        diff: ::prisma_client_rust::serde_json::Value,
        recipe: ::prisma_client_rust::serde_json::Value,
        version: String,
        revision: String,
        change_request_id: String,
        _params: Vec<SetParam>,
    ) -> (
        super::ComponentChangeKind,
        ::prisma_client_rust::serde_json::Value,
        ::prisma_client_rust::serde_json::Value,
        String,
        String,
        String,
        Vec<SetParam>,
    ) {
        (
            kind,
            diff,
            recipe,
            version,
            revision,
            change_request_id,
            _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_component_change { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: component_change :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: component_change :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: component_change :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: component_change :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: component_change :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: component_change :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , kind , diff , component , recipe , version , revision , gate , patches , scripts , archives , change_request , component_name , component_version , component_revision , gate_id , change_request_id } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: component_change :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: component_change :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: component_change :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: component_change :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component_change :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component_change :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "kind" , "diff" , "component" , "recipe" , "version" , "revision" , "gate" , "patches" , "scripts" , "archives" , "change_request" , "componentName" , "componentVersion" , "componentRevision" , "gateId" , "changeRequestId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: component_change :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; kind) => { crate :: prisma :: ComponentChangeKind } ; (@ field_type ; diff) => { :: prisma_client_rust :: serde_json :: Value } ; (@ field_type ; component : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < component :: Data > } ; (@ field_type ; component) => { Option < crate :: prisma :: component :: Data > } ; (@ field_type ; recipe) => { :: prisma_client_rust :: serde_json :: Value } ; (@ field_type ; version) => { String } ; (@ field_type ; revision) => { String } ; (@ field_type ; gate : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < gate :: Data > } ; (@ field_type ; gate) => { Option < crate :: prisma :: gate :: Data > } ; (@ field_type ; patches) => { Vec < String > } ; (@ field_type ; scripts) => { Vec < String > } ; (@ field_type ; archives) => { Vec < String > } ; (@ field_type ; change_request : $ selection_mode : ident { $ ($ selections : tt) + }) => { change_request :: Data } ; (@ field_type ; change_request) => { crate :: prisma :: change_request :: Data } ; (@ field_type ; component_name) => { Option < String > } ; (@ field_type ; component_version) => { Option < String > } ; (@ field_type ; component_revision) => { Option < String > } ; (@ field_type ; gate_id) => { Option < String > } ; (@ field_type ; change_request_id) => { String } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "ComponentChange" , available relations are "id, kind, diff, component, recipe, version, revision, gate, patches, scripts, archives, change_request, component_name, component_version, component_revision, gate_id, change_request_id")) } ; (@ field_module ; component : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: component :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; gate : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: gate :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; change_request : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: change_request :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: component_change :: SelectParam > :: into (crate :: prisma :: component_change :: id :: Select) } ; (@ selection_field_to_selection_param ; kind) => { Into :: < crate :: prisma :: component_change :: SelectParam > :: into (crate :: prisma :: component_change :: kind :: Select) } ; (@ selection_field_to_selection_param ; diff) => { Into :: < crate :: prisma :: component_change :: SelectParam > :: into (crate :: prisma :: component_change :: diff :: Select) } ; (@ selection_field_to_selection_param ; component $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: component_change :: SelectParam > :: into (crate :: prisma :: component_change :: component :: Select :: $ selection_mode (crate :: prisma :: component :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; component $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: component_change :: SelectParam > :: into (crate :: prisma :: component_change :: component :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; recipe) => { Into :: < crate :: prisma :: component_change :: SelectParam > :: into (crate :: prisma :: component_change :: recipe :: Select) } ; (@ selection_field_to_selection_param ; version) => { Into :: < crate :: prisma :: component_change :: SelectParam > :: into (crate :: prisma :: component_change :: version :: Select) } ; (@ selection_field_to_selection_param ; revision) => { Into :: < crate :: prisma :: component_change :: SelectParam > :: into (crate :: prisma :: component_change :: revision :: Select) } ; (@ selection_field_to_selection_param ; gate $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: component_change :: SelectParam > :: into (crate :: prisma :: component_change :: gate :: Select :: $ selection_mode (crate :: prisma :: gate :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; gate $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: component_change :: SelectParam > :: into (crate :: prisma :: component_change :: gate :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; patches) => { Into :: < crate :: prisma :: component_change :: SelectParam > :: into (crate :: prisma :: component_change :: patches :: Select) } ; (@ selection_field_to_selection_param ; scripts) => { Into :: < crate :: prisma :: component_change :: SelectParam > :: into (crate :: prisma :: component_change :: scripts :: Select) } ; (@ selection_field_to_selection_param ; archives) => { Into :: < crate :: prisma :: component_change :: SelectParam > :: into (crate :: prisma :: component_change :: archives :: Select) } ; (@ selection_field_to_selection_param ; change_request $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: component_change :: SelectParam > :: into (crate :: prisma :: component_change :: change_request :: Select :: $ selection_mode (crate :: prisma :: change_request :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; change_request $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: component_change :: SelectParam > :: into (crate :: prisma :: component_change :: change_request :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; component_name) => { Into :: < crate :: prisma :: component_change :: SelectParam > :: into (crate :: prisma :: component_change :: component_name :: Select) } ; (@ selection_field_to_selection_param ; component_version) => { Into :: < crate :: prisma :: component_change :: SelectParam > :: into (crate :: prisma :: component_change :: component_version :: Select) } ; (@ selection_field_to_selection_param ; component_revision) => { Into :: < crate :: prisma :: component_change :: SelectParam > :: into (crate :: prisma :: component_change :: component_revision :: Select) } ; (@ selection_field_to_selection_param ; gate_id) => { Into :: < crate :: prisma :: component_change :: SelectParam > :: into (crate :: prisma :: component_change :: gate_id :: Select) } ; (@ selection_field_to_selection_param ; change_request_id) => { Into :: < crate :: prisma :: component_change :: SelectParam > :: into (crate :: prisma :: component_change :: change_request_id :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: component_change :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; kind) => { "kind" } ; (@ field_serde_name ; diff) => { "diff" } ; (@ field_serde_name ; component) => { "component" } ; (@ field_serde_name ; recipe) => { "recipe" } ; (@ field_serde_name ; version) => { "version" } ; (@ field_serde_name ; revision) => { "revision" } ; (@ field_serde_name ; gate) => { "gate" } ; (@ field_serde_name ; patches) => { "patches" } ; (@ field_serde_name ; scripts) => { "scripts" } ; (@ field_serde_name ; archives) => { "archives" } ; (@ field_serde_name ; change_request) => { "change_request" } ; (@ field_serde_name ; component_name) => { "componentName" } ; (@ field_serde_name ; component_version) => { "componentVersion" } ; (@ field_serde_name ; component_revision) => { "componentRevision" } ; (@ field_serde_name ; gate_id) => { "gateId" } ; (@ field_serde_name ; change_request_id) => { "changeRequestId" } ; }
    pub use _select_component_change as select;
    pub enum SelectParam {
        Id(id::Select),
        Kind(kind::Select),
        Diff(diff::Select),
        Component(component::Select),
        Recipe(recipe::Select),
        Version(version::Select),
        Revision(revision::Select),
        Gate(gate::Select),
        Patches(patches::Select),
        Scripts(scripts::Select),
        Archives(archives::Select),
        ChangeRequest(change_request::Select),
        ComponentName(component_name::Select),
        ComponentVersion(component_version::Select),
        ComponentRevision(component_revision::Select),
        GateId(gate_id::Select),
        ChangeRequestId(change_request_id::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Kind(data) => data.to_selection(),
                Self::Diff(data) => data.to_selection(),
                Self::Component(data) => data.to_selection(),
                Self::Recipe(data) => data.to_selection(),
                Self::Version(data) => data.to_selection(),
                Self::Revision(data) => data.to_selection(),
                Self::Gate(data) => data.to_selection(),
                Self::Patches(data) => data.to_selection(),
                Self::Scripts(data) => data.to_selection(),
                Self::Archives(data) => data.to_selection(),
                Self::ChangeRequest(data) => data.to_selection(),
                Self::ComponentName(data) => data.to_selection(),
                Self::ComponentVersion(data) => data.to_selection(),
                Self::ComponentRevision(data) => data.to_selection(),
                Self::GateId(data) => data.to_selection(),
                Self::ChangeRequestId(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_component_change { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: component_change :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: component_change :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: component_change :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: component_change :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: component_change :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: component_change :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: component_change :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: component_change :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { component , gate , change_request } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub kind : crate :: prisma :: ComponentChangeKind , pub diff : :: prisma_client_rust :: serde_json :: Value , pub recipe : :: prisma_client_rust :: serde_json :: Value , pub version : String , pub revision : String , pub patches : Vec < String > , pub scripts : Vec < String > , pub archives : Vec < String > , pub component_name : Option < String > , pub component_version : Option < String > , pub component_revision : Option < String > , pub gate_id : Option < String > , pub change_request_id : String , $ (pub $ field : crate :: prisma :: component_change :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (kind) , stringify ! (diff) , stringify ! (recipe) , stringify ! (version) , stringify ! (revision) , stringify ! (patches) , stringify ! (scripts) , stringify ! (archives) , stringify ! (component_name) , stringify ! (component_version) , stringify ! (component_revision) , stringify ! (gate_id) , stringify ! (change_request_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: component_change :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: component_change :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: component_change :: kind :: NAME , & self . kind) ? ; state . serialize_field (crate :: prisma :: component_change :: diff :: NAME , & self . diff) ? ; state . serialize_field (crate :: prisma :: component_change :: recipe :: NAME , & self . recipe) ? ; state . serialize_field (crate :: prisma :: component_change :: version :: NAME , & self . version) ? ; state . serialize_field (crate :: prisma :: component_change :: revision :: NAME , & self . revision) ? ; state . serialize_field (crate :: prisma :: component_change :: patches :: NAME , & self . patches) ? ; state . serialize_field (crate :: prisma :: component_change :: scripts :: NAME , & self . scripts) ? ; state . serialize_field (crate :: prisma :: component_change :: archives :: NAME , & self . archives) ? ; state . serialize_field (crate :: prisma :: component_change :: component_name :: NAME , & self . component_name) ? ; state . serialize_field (crate :: prisma :: component_change :: component_version :: NAME , & self . component_version) ? ; state . serialize_field (crate :: prisma :: component_change :: component_revision :: NAME , & self . component_revision) ? ; state . serialize_field (crate :: prisma :: component_change :: gate_id :: NAME , & self . gate_id) ? ; state . serialize_field (crate :: prisma :: component_change :: change_request_id :: NAME , & self . change_request_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , kind , diff , recipe , version , revision , patches , scripts , archives , component_name , component_version , component_revision , gate_id , change_request_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: component_change :: $ field :: NAME) , + , crate :: prisma :: component_change :: id :: NAME , crate :: prisma :: component_change :: kind :: NAME , crate :: prisma :: component_change :: diff :: NAME , crate :: prisma :: component_change :: recipe :: NAME , crate :: prisma :: component_change :: version :: NAME , crate :: prisma :: component_change :: revision :: NAME , crate :: prisma :: component_change :: patches :: NAME , crate :: prisma :: component_change :: scripts :: NAME , crate :: prisma :: component_change :: archives :: NAME , crate :: prisma :: component_change :: component_name :: NAME , crate :: prisma :: component_change :: component_version :: NAME , crate :: prisma :: component_change :: component_revision :: NAME , crate :: prisma :: component_change :: gate_id :: NAME , crate :: prisma :: component_change :: change_request_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: component_change :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: component_change :: id :: NAME => Ok (Field :: id) , crate :: prisma :: component_change :: kind :: NAME => Ok (Field :: kind) , crate :: prisma :: component_change :: diff :: NAME => Ok (Field :: diff) , crate :: prisma :: component_change :: recipe :: NAME => Ok (Field :: recipe) , crate :: prisma :: component_change :: version :: NAME => Ok (Field :: version) , crate :: prisma :: component_change :: revision :: NAME => Ok (Field :: revision) , crate :: prisma :: component_change :: patches :: NAME => Ok (Field :: patches) , crate :: prisma :: component_change :: scripts :: NAME => Ok (Field :: scripts) , crate :: prisma :: component_change :: archives :: NAME => Ok (Field :: archives) , crate :: prisma :: component_change :: component_name :: NAME => Ok (Field :: component_name) , crate :: prisma :: component_change :: component_version :: NAME => Ok (Field :: component_version) , crate :: prisma :: component_change :: component_revision :: NAME => Ok (Field :: component_revision) , crate :: prisma :: component_change :: gate_id :: NAME => Ok (Field :: gate_id) , crate :: prisma :: component_change :: change_request_id :: NAME => Ok (Field :: change_request_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut kind = None ; let mut diff = None ; let mut recipe = None ; let mut version = None ; let mut revision = None ; let mut patches = None ; let mut scripts = None ; let mut archives = None ; let mut component_name = None ; let mut component_version = None ; let mut component_revision = None ; let mut gate_id = None ; let mut change_request_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component_change :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: kind => { if kind . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component_change :: kind :: NAME)) ; } kind = Some (map . next_value () ?) ; } Field :: diff => { if diff . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component_change :: diff :: NAME)) ; } diff = Some (map . next_value () ?) ; } Field :: recipe => { if recipe . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component_change :: recipe :: NAME)) ; } recipe = Some (map . next_value () ?) ; } Field :: version => { if version . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component_change :: version :: NAME)) ; } version = Some (map . next_value () ?) ; } Field :: revision => { if revision . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component_change :: revision :: NAME)) ; } revision = Some (map . next_value () ?) ; } Field :: patches => { if patches . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component_change :: patches :: NAME)) ; } patches = Some (map . next_value () ?) ; } Field :: scripts => { if scripts . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component_change :: scripts :: NAME)) ; } scripts = Some (map . next_value () ?) ; } Field :: archives => { if archives . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component_change :: archives :: NAME)) ; } archives = Some (map . next_value () ?) ; } Field :: component_name => { if component_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component_change :: component_name :: NAME)) ; } component_name = Some (map . next_value () ?) ; } Field :: component_version => { if component_version . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component_change :: component_version :: NAME)) ; } component_version = Some (map . next_value () ?) ; } Field :: component_revision => { if component_revision . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component_change :: component_revision :: NAME)) ; } component_revision = Some (map . next_value () ?) ; } Field :: gate_id => { if gate_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component_change :: gate_id :: NAME)) ; } gate_id = Some (map . next_value () ?) ; } Field :: change_request_id => { if change_request_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component_change :: change_request_id :: NAME)) ; } change_request_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: component_change :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component_change :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component_change :: id :: NAME)) ? ; let kind = kind . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component_change :: kind :: NAME)) ? ; let diff = diff . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component_change :: diff :: NAME)) ? ; let recipe = recipe . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component_change :: recipe :: NAME)) ? ; let version = version . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component_change :: version :: NAME)) ? ; let revision = revision . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component_change :: revision :: NAME)) ? ; let patches = patches . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component_change :: patches :: NAME)) ? ; let scripts = scripts . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component_change :: scripts :: NAME)) ? ; let archives = archives . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component_change :: archives :: NAME)) ? ; let component_name = component_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component_change :: component_name :: NAME)) ? ; let component_version = component_version . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component_change :: component_version :: NAME)) ? ; let component_revision = component_revision . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component_change :: component_revision :: NAME)) ? ; let gate_id = gate_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component_change :: gate_id :: NAME)) ? ; let change_request_id = change_request_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: component_change :: change_request_id :: NAME)) ? ; Ok (Data { id , kind , diff , recipe , version , revision , patches , scripts , archives , component_name , component_version , component_revision , gate_id , change_request_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "kind" , "diff" , "component" , "recipe" , "version" , "revision" , "gate" , "patches" , "scripts" , "archives" , "change_request" , "componentName" , "componentVersion" , "componentRevision" , "gateId" , "changeRequestId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: component_change :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; component : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < component :: Data > } ; (@ field_type ; component) => { Option < crate :: prisma :: component :: Data > } ; (@ field_type ; gate : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < gate :: Data > } ; (@ field_type ; gate) => { Option < crate :: prisma :: gate :: Data > } ; (@ field_type ; change_request : $ selection_mode : ident { $ ($ selections : tt) + }) => { change_request :: Data } ; (@ field_type ; change_request) => { crate :: prisma :: change_request :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "ComponentChange" , available relations are "component, gate, change_request")) } ; (@ field_module ; component : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: component :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; gate : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: gate :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; change_request : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: change_request :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; component $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: component_change :: IncludeParam > :: into (crate :: prisma :: component_change :: component :: Include :: $ selection_mode (crate :: prisma :: component :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; component $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: component_change :: IncludeParam > :: into (crate :: prisma :: component_change :: component :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; gate $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: component_change :: IncludeParam > :: into (crate :: prisma :: component_change :: gate :: Include :: $ selection_mode (crate :: prisma :: gate :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; gate $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: component_change :: IncludeParam > :: into (crate :: prisma :: component_change :: gate :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; change_request $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: component_change :: IncludeParam > :: into (crate :: prisma :: component_change :: change_request :: Include :: $ selection_mode (crate :: prisma :: change_request :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; change_request $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: component_change :: IncludeParam > :: into (crate :: prisma :: component_change :: change_request :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: component_change :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; kind) => { "kind" } ; (@ field_serde_name ; diff) => { "diff" } ; (@ field_serde_name ; component) => { "component" } ; (@ field_serde_name ; recipe) => { "recipe" } ; (@ field_serde_name ; version) => { "version" } ; (@ field_serde_name ; revision) => { "revision" } ; (@ field_serde_name ; gate) => { "gate" } ; (@ field_serde_name ; patches) => { "patches" } ; (@ field_serde_name ; scripts) => { "scripts" } ; (@ field_serde_name ; archives) => { "archives" } ; (@ field_serde_name ; change_request) => { "change_request" } ; (@ field_serde_name ; component_name) => { "componentName" } ; (@ field_serde_name ; component_version) => { "componentVersion" } ; (@ field_serde_name ; component_revision) => { "componentRevision" } ; (@ field_serde_name ; gate_id) => { "gateId" } ; (@ field_serde_name ; change_request_id) => { "changeRequestId" } ; }
    pub use _include_component_change as include;
    pub enum IncludeParam {
        Id(id::Include),
        Kind(kind::Include),
        Diff(diff::Include),
        Component(component::Include),
        Recipe(recipe::Include),
        Version(version::Include),
        Revision(revision::Include),
        Gate(gate::Include),
        Patches(patches::Include),
        Scripts(scripts::Include),
        Archives(archives::Include),
        ChangeRequest(change_request::Include),
        ComponentName(component_name::Include),
        ComponentVersion(component_version::Include),
        ComponentRevision(component_revision::Include),
        GateId(gate_id::Include),
        ChangeRequestId(change_request_id::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Kind(data) => data.to_selection(),
                Self::Diff(data) => data.to_selection(),
                Self::Component(data) => data.to_selection(),
                Self::Recipe(data) => data.to_selection(),
                Self::Version(data) => data.to_selection(),
                Self::Revision(data) => data.to_selection(),
                Self::Gate(data) => data.to_selection(),
                Self::Patches(data) => data.to_selection(),
                Self::Scripts(data) => data.to_selection(),
                Self::Archives(data) => data.to_selection(),
                Self::ChangeRequest(data) => data.to_selection(),
                Self::ComponentName(data) => data.to_selection(),
                Self::ComponentVersion(data) => data.to_selection(),
                Self::ComponentRevision(data) => data.to_selection(),
                Self::GateId(data) => data.to_selection(),
                Self::ChangeRequestId(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_component_change { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: component_change struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "kind")] pub kind : crate :: prisma :: ComponentChangeKind , # [serde (rename = "diff")] pub diff : :: prisma_client_rust :: serde_json :: Value , # [serde (rename = "recipe")] pub recipe : :: prisma_client_rust :: serde_json :: Value , # [serde (rename = "version")] pub version : String , # [serde (rename = "revision")] pub revision : String , # [serde (rename = "patches")] pub patches : Vec < String > , # [serde (rename = "scripts")] pub scripts : Vec < String > , # [serde (rename = "archives")] pub archives : Vec < String > , # [serde (rename = "componentName")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub component_name : Option < String > , # [serde (rename = "componentVersion")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub component_version : Option < String > , # [serde (rename = "componentRevision")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub component_revision : Option < String > , # [serde (rename = "gateId")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub gate_id : Option < String > , # [serde (rename = "changeRequestId")] pub change_request_id : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_component_change as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "kind")]
        pub kind: super::ComponentChangeKind,
        #[serde(rename = "diff")]
        pub diff: ::prisma_client_rust::serde_json::Value,
        #[serde(
            rename = "component",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub component: Option<Option<Box<super::component::Data>>>,
        #[serde(rename = "recipe")]
        pub recipe: ::prisma_client_rust::serde_json::Value,
        #[serde(rename = "version")]
        pub version: String,
        #[serde(rename = "revision")]
        pub revision: String,
        #[serde(
            rename = "gate",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub gate: Option<Option<Box<super::gate::Data>>>,
        #[serde(rename = "patches")]
        pub patches: Vec<String>,
        #[serde(rename = "scripts")]
        pub scripts: Vec<String>,
        #[serde(rename = "archives")]
        pub archives: Vec<String>,
        #[serde(rename = "change_request")]
        pub change_request: Option<Box<super::change_request::Data>>,
        #[serde(rename = "componentName")]
        pub component_name: Option<String>,
        #[serde(rename = "componentVersion")]
        pub component_version: Option<String>,
        #[serde(rename = "componentRevision")]
        pub component_revision: Option<String>,
        #[serde(rename = "gateId")]
        pub gate_id: Option<String>,
        #[serde(rename = "changeRequestId")]
        pub change_request_id: String,
    }
    impl Data {
        pub fn component(
            &self,
        ) -> Result<Option<&super::component::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.component
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(component),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn gate(
            &self,
        ) -> Result<Option<&super::gate::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.gate
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(gate),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn change_request(
            &self,
        ) -> Result<&super::change_request::Data, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.change_request
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(change_request),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Component(super::component::UniqueArgs),
        Gate(super::gate::UniqueArgs),
        ChangeRequest(super::change_request::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Component(args) => {
                    let mut selections = < super :: component :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(component::NAME, None, [], selections)
                }
                Self::Gate(args) => {
                    let mut selections =
                        <super::gate::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(gate::NAME, None, [], selections)
                }
                Self::ChangeRequest(args) => {
                    let mut selections = < super :: change_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(change_request::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetKind(super::ComponentChangeKind),
        SetDiff(::prisma_client_rust::serde_json::Value),
        ConnectComponent(super::component::UniqueWhereParam),
        DisconnectComponent,
        SetRecipe(::prisma_client_rust::serde_json::Value),
        SetVersion(String),
        SetRevision(String),
        ConnectGate(super::gate::UniqueWhereParam),
        DisconnectGate,
        SetPatches(Vec<String>),
        PushPatches(Vec<String>),
        SetScripts(Vec<String>),
        PushScripts(Vec<String>),
        SetArchives(Vec<String>),
        PushArchives(Vec<String>),
        ConnectChangeRequest(super::change_request::UniqueWhereParam),
        SetComponentName(Option<String>),
        SetComponentVersion(Option<String>),
        SetComponentRevision(Option<String>),
        SetGateId(Option<String>),
        SetChangeRequestId(String),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetKind(value) => (
                    kind::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                ),
                SetParam::SetDiff(value) => (
                    diff::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Json(
                        ::prisma_client_rust::serde_json::to_string(&value).unwrap(),
                    ),
                ),
                SetParam::ConnectComponent(where_param) => (
                    component::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::component::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectComponent => (
                    component::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetRecipe(value) => (
                    recipe::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Json(
                        ::prisma_client_rust::serde_json::to_string(&value).unwrap(),
                    ),
                ),
                SetParam::SetVersion(value) => (
                    version::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetRevision(value) => (
                    revision::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectGate(where_param) => (
                    gate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::gate::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectGate => (
                    gate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetPatches(value) => (
                    patches::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .collect(),
                    ),
                ),
                SetParam::PushPatches(value) => (
                    patches::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetScripts(value) => (
                    scripts::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .collect(),
                    ),
                ),
                SetParam::PushScripts(value) => (
                    scripts::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetArchives(value) => (
                    archives::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .collect(),
                    ),
                ),
                SetParam::PushArchives(value) => (
                    archives::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectChangeRequest(where_param) => (
                    change_request::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::change_request::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetComponentName(value) => (
                    component_name::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetComponentVersion(value) => (
                    component_version::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetComponentRevision(value) => (
                    component_revision::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetGateId(value) => (
                    gate_id::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetChangeRequestId(value) => (
                    change_request_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(String),
        Kind(super::ComponentChangeKind),
        Diff(::prisma_client_rust::serde_json::Value),
        Recipe(::prisma_client_rust::serde_json::Value),
        Version(String),
        Revision(String),
        Patches(Vec<String>),
        Scripts(Vec<String>),
        Archives(Vec<String>),
        ComponentName(Option<String>),
        ComponentVersion(Option<String>),
        ComponentRevision(Option<String>),
        GateId(Option<String>),
        ChangeRequestId(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Kind(value) => Self::SetKind(value),
                UncheckedSetParam::Diff(value) => Self::SetDiff(value),
                UncheckedSetParam::Recipe(value) => Self::SetRecipe(value),
                UncheckedSetParam::Version(value) => Self::SetVersion(value),
                UncheckedSetParam::Revision(value) => Self::SetRevision(value),
                UncheckedSetParam::Patches(value) => Self::SetPatches(value),
                UncheckedSetParam::Scripts(value) => Self::SetScripts(value),
                UncheckedSetParam::Archives(value) => Self::SetArchives(value),
                UncheckedSetParam::ComponentName(value) => Self::SetComponentName(value),
                UncheckedSetParam::ComponentVersion(value) => Self::SetComponentVersion(value),
                UncheckedSetParam::ComponentRevision(value) => Self::SetComponentRevision(value),
                UncheckedSetParam::GateId(value) => Self::SetGateId(value),
                UncheckedSetParam::ChangeRequestId(value) => Self::SetChangeRequestId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Kind(::prisma_client_rust::Direction),
        Diff(::prisma_client_rust::Direction),
        Recipe(::prisma_client_rust::Direction),
        Version(::prisma_client_rust::Direction),
        Revision(::prisma_client_rust::Direction),
        Patches(::prisma_client_rust::Direction),
        Scripts(::prisma_client_rust::Direction),
        Archives(::prisma_client_rust::Direction),
        ComponentName(::prisma_client_rust::Direction),
        ComponentVersion(::prisma_client_rust::Direction),
        ComponentRevision(::prisma_client_rust::Direction),
        GateId(::prisma_client_rust::Direction),
        ChangeRequestId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Kind(direction) => (
                    kind::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Diff(direction) => (
                    diff::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Recipe(direction) => (
                    recipe::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Version(direction) => (
                    version::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Revision(direction) => (
                    revision::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Patches(direction) => (
                    patches::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Scripts(direction) => (
                    scripts::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Archives(direction) => (
                    archives::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ComponentName(direction) => (
                    component_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ComponentVersion(direction) => (
                    component_version::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ComponentRevision(direction) => (
                    component_revision::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::GateId(direction) => (
                    gate_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ChangeRequestId(direction) => (
                    change_request_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        Kind(_prisma::read_filters::ComponentChangeKindFilter),
        Diff(_prisma::read_filters::JsonFilter),
        ComponentIsNull,
        ComponentIs(Vec<super::component::WhereParam>),
        ComponentIsNot(Vec<super::component::WhereParam>),
        Recipe(_prisma::read_filters::JsonFilter),
        Version(_prisma::read_filters::StringFilter),
        Revision(_prisma::read_filters::StringFilter),
        GateIsNull,
        GateIs(Vec<super::gate::WhereParam>),
        GateIsNot(Vec<super::gate::WhereParam>),
        Patches(_prisma::read_filters::StringListFilter),
        Scripts(_prisma::read_filters::StringListFilter),
        Archives(_prisma::read_filters::StringListFilter),
        ChangeRequestIs(Vec<super::change_request::WhereParam>),
        ChangeRequestIsNot(Vec<super::change_request::WhereParam>),
        ComponentName(_prisma::read_filters::StringNullableFilter),
        ComponentVersion(_prisma::read_filters::StringNullableFilter),
        ComponentRevision(_prisma::read_filters::StringNullableFilter),
        GateId(_prisma::read_filters::StringNullableFilter),
        ChangeRequestId(_prisma::read_filters::StringFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Kind(value) => (kind::NAME, value.into()),
                Self::Diff(value) => (diff::NAME, value.into()),
                Self::ComponentIsNull => (
                    component::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::ComponentIs(where_params) => (
                    component::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ComponentIsNot(where_params) => (
                    component::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::Recipe(value) => (recipe::NAME, value.into()),
                Self::Version(value) => (version::NAME, value.into()),
                Self::Revision(value) => (revision::NAME, value.into()),
                Self::GateIsNull => (
                    gate::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::GateIs(where_params) => (
                    gate::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::GateIsNot(where_params) => (
                    gate::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::Patches(value) => (patches::NAME, value.into()),
                Self::Scripts(value) => (scripts::NAME, value.into()),
                Self::Archives(value) => (archives::NAME, value.into()),
                Self::ChangeRequestIs(where_params) => (
                    change_request::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ChangeRequestIsNot(where_params) => (
                    change_request::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ComponentName(value) => (component_name::NAME, value.into()),
                Self::ComponentVersion(value) => (component_version::NAME, value.into()),
                Self::ComponentRevision(value) => (component_revision::NAME, value.into()),
                Self::GateId(value) => (gate_id::NAME, value.into()),
                Self::ChangeRequestId(value) => (change_request_id::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(kind::NAME),
                ::prisma_client_rust::sel(diff::NAME),
                ::prisma_client_rust::sel(recipe::NAME),
                ::prisma_client_rust::sel(version::NAME),
                ::prisma_client_rust::sel(revision::NAME),
                ::prisma_client_rust::sel(patches::NAME),
                ::prisma_client_rust::sel(scripts::NAME),
                ::prisma_client_rust::sel(archives::NAME),
                ::prisma_client_rust::sel(component_name::NAME),
                ::prisma_client_rust::sel(component_version::NAME),
                ::prisma_client_rust::sel(component_revision::NAME),
                ::prisma_client_rust::sel(gate_id::NAME),
                ::prisma_client_rust::sel(change_request_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            kind: super::ComponentChangeKind,
            diff: ::prisma_client_rust::serde_json::Value,
            recipe: ::prisma_client_rust::serde_json::Value,
            version: String,
            revision: String,
            change_request: super::change_request::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                kind::set(kind),
                diff::set(diff),
                recipe::set(recipe),
                version::set(version),
                revision::set(revision),
                change_request::connect(change_request),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            kind: super::ComponentChangeKind,
            diff: ::prisma_client_rust::serde_json::Value,
            recipe: ::prisma_client_rust::serde_json::Value,
            version: String,
            revision: String,
            change_request_id: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                kind::set(kind),
                diff::set(diff),
                recipe::set(recipe),
                version::set(version),
                revision::set(revision),
                change_request_id::set(change_request_id),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(
                super::ComponentChangeKind,
                ::prisma_client_rust::serde_json::Value,
                ::prisma_client_rust::serde_json::Value,
                String,
                String,
                String,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(kind, diff, recipe, version, revision, change_request_id, mut _params)| {
                        _params.extend([
                            kind::set(kind),
                            diff::set(diff),
                            recipe::set(recipe),
                            version::set(version),
                            revision::set(revision),
                            change_request_id::set(change_request_id),
                        ]);
                        _params
                    },
                )
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (kind, diff, recipe, version, revision, change_request, mut _params): (
                super::ComponentChangeKind,
                ::prisma_client_rust::serde_json::Value,
                ::prisma_client_rust::serde_json::Value,
                String,
                String,
                super::change_request::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                kind::set(kind),
                diff::set(diff),
                recipe::set(recipe),
                version::set(version),
                revision::set(revision),
                change_request::connect(change_request),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod change_request {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "ChangeRequest";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod processing {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "processing";
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetProcessing(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Processing(v)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Processing(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::Processing(_prisma::read_filters::BoolFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BoolFilter,
            Processing,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Processing(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Processing(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod component_changes {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "component_changes";
        pub struct Fetch(pub component_change::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<component_change::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: component_change::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: component_change::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::ComponentChanges(v)
            }
        }
        pub fn fetch(params: Vec<component_change::WhereParam>) -> Fetch {
            Fetch(component_change::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<component_change::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectComponentChanges(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<component_change::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<component_change::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectComponentChanges(params)
        }
        pub fn set(params: Vec<component_change::UniqueWhereParam>) -> SetParam {
            SetParam::SetComponentChanges(params)
        }
        pub fn some(value: Vec<component_change::WhereParam>) -> WhereParam {
            WhereParam::ComponentChangesSome(value)
        }
        pub fn every(value: Vec<component_change::WhereParam>) -> WhereParam {
            WhereParam::ComponentChangesEvery(value)
        }
        pub fn none(value: Vec<component_change::WhereParam>) -> WhereParam {
            WhereParam::ComponentChangesNone(value)
        }
        pub enum Include {
            Select(
                component_change::ManyArgs,
                Vec<component_change::SelectParam>,
            ),
            Include(
                component_change::ManyArgs,
                Vec<component_change::IncludeParam>,
            ),
            Fetch(component_change::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ComponentChanges(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < component_change :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < component_change :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: component_change::ManyArgs,
                nested_selections: Vec<component_change::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: component_change::ManyArgs,
                nested_selections: Vec<component_change::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                component_change::ManyArgs,
                Vec<component_change::SelectParam>,
            ),
            Include(
                component_change::ManyArgs,
                Vec<component_change::IncludeParam>,
            ),
            Fetch(component_change::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ComponentChanges(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < component_change :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: component_change::ManyArgs,
                nested_selections: Vec<component_change::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: component_change::ManyArgs,
                nested_selections: Vec<component_change::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod wait_for_request {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "waitForRequest";
        pub struct Fetch(pub change_request::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<change_request::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::WaitForRequest(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(change_request::UniqueArgs::new())
        }
        pub struct Connect(change_request::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectWaitForRequest(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: change_request::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectWaitForRequest
        }
        pub fn is_null() -> WhereParam {
            WhereParam::WaitForRequestIsNull
        }
        pub fn is(value: Vec<change_request::WhereParam>) -> WhereParam {
            WhereParam::WaitForRequestIs(value)
        }
        pub fn is_not(value: Vec<change_request::WhereParam>) -> WhereParam {
            WhereParam::WaitForRequestIsNot(value)
        }
        pub enum Include {
            Select(Vec<change_request::SelectParam>),
            Include(Vec<change_request::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::WaitForRequest(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = < change_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < change_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("waitForRequest", None, [], selections)
            }
            pub fn select(nested_selections: Vec<change_request::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<change_request::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<change_request::SelectParam>),
            Include(Vec<change_request::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::WaitForRequest(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < change_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("waitForRequest", None, [], selections)
            }
            pub fn select(nested_selections: Vec<change_request::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<change_request::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod wait_for_request_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "waitForRequestId";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetWaitForRequestId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::WaitForRequestId(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::WaitForRequestId(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::WaitForRequestId(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            WaitForRequestId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::WaitForRequestId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::WaitForRequestId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod dependant_requests {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "dependantRequests";
        pub struct Fetch(pub change_request::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<change_request::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: change_request::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: change_request::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::DependantRequests(v)
            }
        }
        pub fn fetch(params: Vec<change_request::WhereParam>) -> Fetch {
            Fetch(change_request::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<change_request::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectDependantRequests(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<change_request::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<change_request::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectDependantRequests(params)
        }
        pub fn set(params: Vec<change_request::UniqueWhereParam>) -> SetParam {
            SetParam::SetDependantRequests(params)
        }
        pub fn some(value: Vec<change_request::WhereParam>) -> WhereParam {
            WhereParam::DependantRequestsSome(value)
        }
        pub fn every(value: Vec<change_request::WhereParam>) -> WhereParam {
            WhereParam::DependantRequestsEvery(value)
        }
        pub fn none(value: Vec<change_request::WhereParam>) -> WhereParam {
            WhereParam::DependantRequestsNone(value)
        }
        pub enum Include {
            Select(change_request::ManyArgs, Vec<change_request::SelectParam>),
            Include(change_request::ManyArgs, Vec<change_request::IncludeParam>),
            Fetch(change_request::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::DependantRequests(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < change_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < change_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: change_request::ManyArgs,
                nested_selections: Vec<change_request::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: change_request::ManyArgs,
                nested_selections: Vec<change_request::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(change_request::ManyArgs, Vec<change_request::SelectParam>),
            Include(change_request::ManyArgs, Vec<change_request::IncludeParam>),
            Fetch(change_request::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::DependantRequests(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < change_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: change_request::ManyArgs,
                nested_selections: Vec<change_request::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: change_request::ManyArgs,
                nested_selections: Vec<change_request::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod build_order {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "build_order";
        pub struct Set(pub Vec<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetBuildOrder(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::BuildOrder(v)
            }
        }
        pub fn set<T: From<Set>>(value: Vec<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::BuildOrder(direction)
        }
        pub fn equals(value: Vec<String>) -> WhereParam {
            WhereParam::BuildOrder(_prisma::read_filters::StringListFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringListFilter,
            BuildOrder,
            {
                fn has(_: Option<String>) -> Has;
                fn has_every(_: Vec<String>) -> HasEvery;
                fn has_some(_: Vec<String>) -> HasSome;
                fn is_empty(_: bool) -> IsEmpty;
            }
        );
        pub fn push(value: Vec<String>) -> SetParam {
            SetParam::PushBuildOrder(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::BuildOrder(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::BuildOrder(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod external_reference {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "external_reference";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetExternalReference(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ExternalReference(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ExternalReference(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::ExternalReference(_prisma::read_filters::StringNullableFilter::Equals(
                value,
            ))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            ExternalReference,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ExternalReference(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ExternalReference(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod jobs {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "Jobs";
        pub struct Fetch(pub build_job::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<build_job::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: build_job::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: build_job::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Jobs(v)
            }
        }
        pub fn fetch(params: Vec<build_job::WhereParam>) -> Fetch {
            Fetch(build_job::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<build_job::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectJobs(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<build_job::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<build_job::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectJobs(params)
        }
        pub fn set(params: Vec<build_job::UniqueWhereParam>) -> SetParam {
            SetParam::SetJobs(params)
        }
        pub fn some(value: Vec<build_job::WhereParam>) -> WhereParam {
            WhereParam::JobsSome(value)
        }
        pub fn every(value: Vec<build_job::WhereParam>) -> WhereParam {
            WhereParam::JobsEvery(value)
        }
        pub fn none(value: Vec<build_job::WhereParam>) -> WhereParam {
            WhereParam::JobsNone(value)
        }
        pub enum Include {
            Select(build_job::ManyArgs, Vec<build_job::SelectParam>),
            Include(build_job::ManyArgs, Vec<build_job::IncludeParam>),
            Fetch(build_job::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Jobs(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = < build_job :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <build_job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: build_job::ManyArgs,
                nested_selections: Vec<build_job::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: build_job::ManyArgs,
                nested_selections: Vec<build_job::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(build_job::ManyArgs, Vec<build_job::SelectParam>),
            Include(build_job::ManyArgs, Vec<build_job::IncludeParam>),
            Fetch(build_job::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Jobs(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <build_job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: build_job::ManyArgs,
                nested_selections: Vec<build_job::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: build_job::ManyArgs,
                nested_selections: Vec<build_job::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(_params: Vec<SetParam>) -> (Vec<SetParam>) {
        (_params)
    }
    pub fn create_unchecked(_params: Vec<SetParam>) -> (Vec<SetParam>) {
        (_params)
    }
    #[macro_export]
    macro_rules ! _select_change_request { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: change_request :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: change_request :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: change_request :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: change_request :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: change_request :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: change_request :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , processing , component_changes , wait_for_request , wait_for_request_id , dependant_requests , build_order , external_reference , jobs } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: change_request :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: change_request :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: change_request :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: change_request :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: change_request :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: change_request :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "processing" , "component_changes" , "waitForRequest" , "waitForRequestId" , "dependantRequests" , "build_order" , "external_reference" , "Jobs"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: change_request :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; processing) => { bool } ; (@ field_type ; component_changes : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < component_changes :: Data > } ; (@ field_type ; component_changes) => { Vec < crate :: prisma :: component_change :: Data > } ; (@ field_type ; wait_for_request : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < wait_for_request :: Data > } ; (@ field_type ; wait_for_request) => { Option < crate :: prisma :: change_request :: Data > } ; (@ field_type ; wait_for_request_id) => { Option < String > } ; (@ field_type ; dependant_requests : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < dependant_requests :: Data > } ; (@ field_type ; dependant_requests) => { Vec < crate :: prisma :: change_request :: Data > } ; (@ field_type ; build_order) => { Vec < String > } ; (@ field_type ; external_reference) => { Option < String > } ; (@ field_type ; jobs : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < jobs :: Data > } ; (@ field_type ; jobs) => { Vec < crate :: prisma :: build_job :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "ChangeRequest" , available relations are "id, processing, component_changes, wait_for_request, wait_for_request_id, dependant_requests, build_order, external_reference, jobs")) } ; (@ field_module ; component_changes : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: component_change :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; wait_for_request : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: change_request :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; dependant_requests : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: change_request :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; jobs : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: build_job :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: change_request :: SelectParam > :: into (crate :: prisma :: change_request :: id :: Select) } ; (@ selection_field_to_selection_param ; processing) => { Into :: < crate :: prisma :: change_request :: SelectParam > :: into (crate :: prisma :: change_request :: processing :: Select) } ; (@ selection_field_to_selection_param ; component_changes $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: change_request :: SelectParam > :: into (crate :: prisma :: change_request :: component_changes :: Select :: $ selection_mode (crate :: prisma :: component_change :: ManyArgs :: new (crate :: prisma :: component_change :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: component_change :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; component_changes $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: change_request :: SelectParam > :: into (crate :: prisma :: change_request :: component_changes :: Select :: Fetch (crate :: prisma :: component_change :: ManyArgs :: new (crate :: prisma :: component_change :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; wait_for_request $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: change_request :: SelectParam > :: into (crate :: prisma :: change_request :: wait_for_request :: Select :: $ selection_mode (crate :: prisma :: change_request :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; wait_for_request $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: change_request :: SelectParam > :: into (crate :: prisma :: change_request :: wait_for_request :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; wait_for_request_id) => { Into :: < crate :: prisma :: change_request :: SelectParam > :: into (crate :: prisma :: change_request :: wait_for_request_id :: Select) } ; (@ selection_field_to_selection_param ; dependant_requests $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: change_request :: SelectParam > :: into (crate :: prisma :: change_request :: dependant_requests :: Select :: $ selection_mode (crate :: prisma :: change_request :: ManyArgs :: new (crate :: prisma :: change_request :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: change_request :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; dependant_requests $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: change_request :: SelectParam > :: into (crate :: prisma :: change_request :: dependant_requests :: Select :: Fetch (crate :: prisma :: change_request :: ManyArgs :: new (crate :: prisma :: change_request :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; build_order) => { Into :: < crate :: prisma :: change_request :: SelectParam > :: into (crate :: prisma :: change_request :: build_order :: Select) } ; (@ selection_field_to_selection_param ; external_reference) => { Into :: < crate :: prisma :: change_request :: SelectParam > :: into (crate :: prisma :: change_request :: external_reference :: Select) } ; (@ selection_field_to_selection_param ; jobs $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: change_request :: SelectParam > :: into (crate :: prisma :: change_request :: jobs :: Select :: $ selection_mode (crate :: prisma :: build_job :: ManyArgs :: new (crate :: prisma :: build_job :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: build_job :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; jobs $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: change_request :: SelectParam > :: into (crate :: prisma :: change_request :: jobs :: Select :: Fetch (crate :: prisma :: build_job :: ManyArgs :: new (crate :: prisma :: build_job :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: change_request :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; processing) => { "processing" } ; (@ field_serde_name ; component_changes) => { "component_changes" } ; (@ field_serde_name ; wait_for_request) => { "waitForRequest" } ; (@ field_serde_name ; wait_for_request_id) => { "waitForRequestId" } ; (@ field_serde_name ; dependant_requests) => { "dependantRequests" } ; (@ field_serde_name ; build_order) => { "build_order" } ; (@ field_serde_name ; external_reference) => { "external_reference" } ; (@ field_serde_name ; jobs) => { "Jobs" } ; }
    pub use _select_change_request as select;
    pub enum SelectParam {
        Id(id::Select),
        Processing(processing::Select),
        ComponentChanges(component_changes::Select),
        WaitForRequest(wait_for_request::Select),
        WaitForRequestId(wait_for_request_id::Select),
        DependantRequests(dependant_requests::Select),
        BuildOrder(build_order::Select),
        ExternalReference(external_reference::Select),
        Jobs(jobs::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Processing(data) => data.to_selection(),
                Self::ComponentChanges(data) => data.to_selection(),
                Self::WaitForRequest(data) => data.to_selection(),
                Self::WaitForRequestId(data) => data.to_selection(),
                Self::DependantRequests(data) => data.to_selection(),
                Self::BuildOrder(data) => data.to_selection(),
                Self::ExternalReference(data) => data.to_selection(),
                Self::Jobs(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_change_request { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: change_request :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: change_request :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: change_request :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: change_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: change_request :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: change_request :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: change_request :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: change_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { component_changes , wait_for_request , dependant_requests , jobs } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub processing : bool , pub wait_for_request_id : Option < String > , pub build_order : Vec < String > , pub external_reference : Option < String > , $ (pub $ field : crate :: prisma :: change_request :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (processing) , stringify ! (wait_for_request_id) , stringify ! (build_order) , stringify ! (external_reference)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: change_request :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: change_request :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: change_request :: processing :: NAME , & self . processing) ? ; state . serialize_field (crate :: prisma :: change_request :: wait_for_request_id :: NAME , & self . wait_for_request_id) ? ; state . serialize_field (crate :: prisma :: change_request :: build_order :: NAME , & self . build_order) ? ; state . serialize_field (crate :: prisma :: change_request :: external_reference :: NAME , & self . external_reference) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , processing , wait_for_request_id , build_order , external_reference } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: change_request :: $ field :: NAME) , + , crate :: prisma :: change_request :: id :: NAME , crate :: prisma :: change_request :: processing :: NAME , crate :: prisma :: change_request :: wait_for_request_id :: NAME , crate :: prisma :: change_request :: build_order :: NAME , crate :: prisma :: change_request :: external_reference :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: change_request :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: change_request :: id :: NAME => Ok (Field :: id) , crate :: prisma :: change_request :: processing :: NAME => Ok (Field :: processing) , crate :: prisma :: change_request :: wait_for_request_id :: NAME => Ok (Field :: wait_for_request_id) , crate :: prisma :: change_request :: build_order :: NAME => Ok (Field :: build_order) , crate :: prisma :: change_request :: external_reference :: NAME => Ok (Field :: external_reference) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut processing = None ; let mut wait_for_request_id = None ; let mut build_order = None ; let mut external_reference = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: change_request :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: processing => { if processing . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: change_request :: processing :: NAME)) ; } processing = Some (map . next_value () ?) ; } Field :: wait_for_request_id => { if wait_for_request_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: change_request :: wait_for_request_id :: NAME)) ; } wait_for_request_id = Some (map . next_value () ?) ; } Field :: build_order => { if build_order . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: change_request :: build_order :: NAME)) ; } build_order = Some (map . next_value () ?) ; } Field :: external_reference => { if external_reference . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: change_request :: external_reference :: NAME)) ; } external_reference = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: change_request :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: change_request :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: change_request :: id :: NAME)) ? ; let processing = processing . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: change_request :: processing :: NAME)) ? ; let wait_for_request_id = wait_for_request_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: change_request :: wait_for_request_id :: NAME)) ? ; let build_order = build_order . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: change_request :: build_order :: NAME)) ? ; let external_reference = external_reference . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: change_request :: external_reference :: NAME)) ? ; Ok (Data { id , processing , wait_for_request_id , build_order , external_reference , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "processing" , "component_changes" , "waitForRequest" , "waitForRequestId" , "dependantRequests" , "build_order" , "external_reference" , "Jobs"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: change_request :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; component_changes : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < component_changes :: Data > } ; (@ field_type ; component_changes) => { Vec < crate :: prisma :: component_change :: Data > } ; (@ field_type ; wait_for_request : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < wait_for_request :: Data > } ; (@ field_type ; wait_for_request) => { Option < crate :: prisma :: change_request :: Data > } ; (@ field_type ; dependant_requests : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < dependant_requests :: Data > } ; (@ field_type ; dependant_requests) => { Vec < crate :: prisma :: change_request :: Data > } ; (@ field_type ; jobs : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < jobs :: Data > } ; (@ field_type ; jobs) => { Vec < crate :: prisma :: build_job :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "ChangeRequest" , available relations are "component_changes, wait_for_request, dependant_requests, jobs")) } ; (@ field_module ; component_changes : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: component_change :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; wait_for_request : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: change_request :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; dependant_requests : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: change_request :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; jobs : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: build_job :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; component_changes $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: change_request :: IncludeParam > :: into (crate :: prisma :: change_request :: component_changes :: Include :: $ selection_mode (crate :: prisma :: component_change :: ManyArgs :: new (crate :: prisma :: component_change :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: component_change :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; component_changes $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: change_request :: IncludeParam > :: into (crate :: prisma :: change_request :: component_changes :: Include :: Fetch (crate :: prisma :: component_change :: ManyArgs :: new (crate :: prisma :: component_change :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; wait_for_request $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: change_request :: IncludeParam > :: into (crate :: prisma :: change_request :: wait_for_request :: Include :: $ selection_mode (crate :: prisma :: change_request :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; wait_for_request $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: change_request :: IncludeParam > :: into (crate :: prisma :: change_request :: wait_for_request :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; dependant_requests $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: change_request :: IncludeParam > :: into (crate :: prisma :: change_request :: dependant_requests :: Include :: $ selection_mode (crate :: prisma :: change_request :: ManyArgs :: new (crate :: prisma :: change_request :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: change_request :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; dependant_requests $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: change_request :: IncludeParam > :: into (crate :: prisma :: change_request :: dependant_requests :: Include :: Fetch (crate :: prisma :: change_request :: ManyArgs :: new (crate :: prisma :: change_request :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; jobs $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: change_request :: IncludeParam > :: into (crate :: prisma :: change_request :: jobs :: Include :: $ selection_mode (crate :: prisma :: build_job :: ManyArgs :: new (crate :: prisma :: build_job :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: build_job :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; jobs $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: change_request :: IncludeParam > :: into (crate :: prisma :: change_request :: jobs :: Include :: Fetch (crate :: prisma :: build_job :: ManyArgs :: new (crate :: prisma :: build_job :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: change_request :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; processing) => { "processing" } ; (@ field_serde_name ; component_changes) => { "component_changes" } ; (@ field_serde_name ; wait_for_request) => { "waitForRequest" } ; (@ field_serde_name ; wait_for_request_id) => { "waitForRequestId" } ; (@ field_serde_name ; dependant_requests) => { "dependantRequests" } ; (@ field_serde_name ; build_order) => { "build_order" } ; (@ field_serde_name ; external_reference) => { "external_reference" } ; (@ field_serde_name ; jobs) => { "Jobs" } ; }
    pub use _include_change_request as include;
    pub enum IncludeParam {
        Id(id::Include),
        Processing(processing::Include),
        ComponentChanges(component_changes::Include),
        WaitForRequest(wait_for_request::Include),
        WaitForRequestId(wait_for_request_id::Include),
        DependantRequests(dependant_requests::Include),
        BuildOrder(build_order::Include),
        ExternalReference(external_reference::Include),
        Jobs(jobs::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Processing(data) => data.to_selection(),
                Self::ComponentChanges(data) => data.to_selection(),
                Self::WaitForRequest(data) => data.to_selection(),
                Self::WaitForRequestId(data) => data.to_selection(),
                Self::DependantRequests(data) => data.to_selection(),
                Self::BuildOrder(data) => data.to_selection(),
                Self::ExternalReference(data) => data.to_selection(),
                Self::Jobs(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_change_request { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: change_request struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "processing")] pub processing : bool , # [serde (rename = "waitForRequestId")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub wait_for_request_id : Option < String > , # [serde (rename = "build_order")] pub build_order : Vec < String > , # [serde (rename = "external_reference")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub external_reference : Option < String > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_change_request as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "processing")]
        pub processing: bool,
        #[serde(rename = "component_changes")]
        pub component_changes: Option<Vec<super::component_change::Data>>,
        #[serde(
            rename = "waitForRequest",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub wait_for_request: Option<Option<Box<super::change_request::Data>>>,
        #[serde(rename = "waitForRequestId")]
        pub wait_for_request_id: Option<String>,
        #[serde(rename = "dependantRequests")]
        pub dependant_requests: Option<Vec<super::change_request::Data>>,
        #[serde(rename = "build_order")]
        pub build_order: Vec<String>,
        #[serde(rename = "external_reference")]
        pub external_reference: Option<String>,
        #[serde(rename = "Jobs")]
        pub jobs: Option<Vec<super::build_job::Data>>,
    }
    impl Data {
        pub fn component_changes(
            &self,
        ) -> Result<
            &Vec<super::component_change::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.component_changes.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(component_changes)),
            )
        }
        pub fn wait_for_request(
            &self,
        ) -> Result<
            Option<&super::change_request::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.wait_for_request
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(wait_for_request),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn dependant_requests(
            &self,
        ) -> Result<&Vec<super::change_request::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.dependant_requests.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(dependant_requests)),
            )
        }
        pub fn jobs(
            &self,
        ) -> Result<&Vec<super::build_job::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.jobs
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(jobs),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        ComponentChanges(super::component_change::ManyArgs),
        WaitForRequest(super::change_request::UniqueArgs),
        DependantRequests(super::change_request::ManyArgs),
        Jobs(super::build_job::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::ComponentChanges(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: component_change :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        component_changes::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::WaitForRequest(args) => {
                    let mut selections = < super :: change_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(
                        wait_for_request::NAME,
                        None,
                        [],
                        selections,
                    )
                }
                Self::DependantRequests(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: change_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        dependant_requests::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Jobs(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: build_job :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        jobs::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetProcessing(bool),
        ConnectComponentChanges(Vec<super::component_change::UniqueWhereParam>),
        DisconnectComponentChanges(Vec<super::component_change::UniqueWhereParam>),
        SetComponentChanges(Vec<super::component_change::UniqueWhereParam>),
        ConnectWaitForRequest(super::change_request::UniqueWhereParam),
        DisconnectWaitForRequest,
        SetWaitForRequestId(Option<String>),
        ConnectDependantRequests(Vec<super::change_request::UniqueWhereParam>),
        DisconnectDependantRequests(Vec<super::change_request::UniqueWhereParam>),
        SetDependantRequests(Vec<super::change_request::UniqueWhereParam>),
        SetBuildOrder(Vec<String>),
        PushBuildOrder(Vec<String>),
        SetExternalReference(Option<String>),
        ConnectJobs(Vec<super::build_job::UniqueWhereParam>),
        DisconnectJobs(Vec<super::build_job::UniqueWhereParam>),
        SetJobs(Vec<super::build_job::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetProcessing(value) => (
                    processing::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::ConnectComponentChanges(where_params) => (
                    component_changes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::component_change::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectComponentChanges(where_params) => (
                    component_changes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::component_change::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetComponentChanges(where_params) => (
                    component_changes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::component_change::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectWaitForRequest(where_param) => (
                    wait_for_request::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::change_request::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectWaitForRequest => (
                    wait_for_request::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetWaitForRequestId(value) => (
                    wait_for_request_id::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::ConnectDependantRequests(where_params) => (
                    dependant_requests::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::change_request::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectDependantRequests(where_params) => (
                    dependant_requests::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::change_request::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetDependantRequests(where_params) => (
                    dependant_requests::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::change_request::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetBuildOrder(value) => (
                    build_order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .collect(),
                    ),
                ),
                SetParam::PushBuildOrder(value) => (
                    build_order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetExternalReference(value) => (
                    external_reference::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::ConnectJobs(where_params) => (
                    jobs::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::build_job::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectJobs(where_params) => (
                    jobs::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::build_job::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetJobs(where_params) => (
                    jobs::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::build_job::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(String),
        Processing(bool),
        WaitForRequestId(Option<String>),
        BuildOrder(Vec<String>),
        ExternalReference(Option<String>),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Processing(value) => Self::SetProcessing(value),
                UncheckedSetParam::WaitForRequestId(value) => Self::SetWaitForRequestId(value),
                UncheckedSetParam::BuildOrder(value) => Self::SetBuildOrder(value),
                UncheckedSetParam::ExternalReference(value) => Self::SetExternalReference(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Processing(::prisma_client_rust::Direction),
        WaitForRequestId(::prisma_client_rust::Direction),
        BuildOrder(::prisma_client_rust::Direction),
        ExternalReference(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Processing(direction) => (
                    processing::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::WaitForRequestId(direction) => (
                    wait_for_request_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::BuildOrder(direction) => (
                    build_order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ExternalReference(direction) => (
                    external_reference::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        Processing(_prisma::read_filters::BoolFilter),
        ComponentChangesSome(Vec<super::component_change::WhereParam>),
        ComponentChangesEvery(Vec<super::component_change::WhereParam>),
        ComponentChangesNone(Vec<super::component_change::WhereParam>),
        WaitForRequestIsNull,
        WaitForRequestIs(Vec<super::change_request::WhereParam>),
        WaitForRequestIsNot(Vec<super::change_request::WhereParam>),
        WaitForRequestId(_prisma::read_filters::StringNullableFilter),
        DependantRequestsSome(Vec<super::change_request::WhereParam>),
        DependantRequestsEvery(Vec<super::change_request::WhereParam>),
        DependantRequestsNone(Vec<super::change_request::WhereParam>),
        BuildOrder(_prisma::read_filters::StringListFilter),
        ExternalReference(_prisma::read_filters::StringNullableFilter),
        JobsSome(Vec<super::build_job::WhereParam>),
        JobsEvery(Vec<super::build_job::WhereParam>),
        JobsNone(Vec<super::build_job::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Processing(value) => (processing::NAME, value.into()),
                Self::ComponentChangesSome(where_params) => (
                    component_changes::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ComponentChangesEvery(where_params) => (
                    component_changes::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ComponentChangesNone(where_params) => (
                    component_changes::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::WaitForRequestIsNull => (
                    wait_for_request::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::WaitForRequestIs(where_params) => (
                    wait_for_request::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::WaitForRequestIsNot(where_params) => (
                    wait_for_request::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::WaitForRequestId(value) => (wait_for_request_id::NAME, value.into()),
                Self::DependantRequestsSome(where_params) => (
                    dependant_requests::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DependantRequestsEvery(where_params) => (
                    dependant_requests::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DependantRequestsNone(where_params) => (
                    dependant_requests::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BuildOrder(value) => (build_order::NAME, value.into()),
                Self::ExternalReference(value) => (external_reference::NAME, value.into()),
                Self::JobsSome(where_params) => (
                    jobs::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::JobsEvery(where_params) => (
                    jobs::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::JobsNone(where_params) => (
                    jobs::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(processing::NAME),
                ::prisma_client_rust::sel(wait_for_request_id::NAME),
                ::prisma_client_rust::sel(build_order::NAME),
                ::prisma_client_rust::sel(external_reference::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(self, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.extend([]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(self, mut _params: Vec<UncheckedSetParam>) -> Create<'a> {
            _params.extend([]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(mut _params)| {
                    _params.extend([]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (mut _params): (Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod build_job {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "BuildJob";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod component {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "component";
        pub struct Fetch(pub component::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<component::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Component(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(component::UniqueArgs::new())
        }
        pub struct Connect(component::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectComponent(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: component::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectComponent
        }
        pub fn is_null() -> WhereParam {
            WhereParam::ComponentIsNull
        }
        pub fn is(value: Vec<component::WhereParam>) -> WhereParam {
            WhereParam::ComponentIs(value)
        }
        pub fn is_not(value: Vec<component::WhereParam>) -> WhereParam {
            WhereParam::ComponentIsNot(value)
        }
        pub enum Include {
            Select(Vec<component::SelectParam>),
            Include(Vec<component::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Component(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = < component :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <component::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("component", None, [], selections)
            }
            pub fn select(nested_selections: Vec<component::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<component::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<component::SelectParam>),
            Include(Vec<component::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Component(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <component::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("component", None, [], selections)
            }
            pub fn select(nested_selections: Vec<component::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<component::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod change_request {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "change_request";
        pub struct Fetch(pub change_request::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<change_request::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::ChangeRequest(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(change_request::UniqueArgs::new())
        }
        pub struct Connect(change_request::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectChangeRequest(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: change_request::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<change_request::WhereParam>) -> WhereParam {
            WhereParam::ChangeRequestIs(value)
        }
        pub fn is_not(value: Vec<change_request::WhereParam>) -> WhereParam {
            WhereParam::ChangeRequestIsNot(value)
        }
        pub enum Include {
            Select(Vec<change_request::SelectParam>),
            Include(Vec<change_request::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ChangeRequest(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = < change_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < change_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("change_request", None, [], selections)
            }
            pub fn select(nested_selections: Vec<change_request::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<change_request::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<change_request::SelectParam>),
            Include(Vec<change_request::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ChangeRequest(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < change_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("change_request", None, [], selections)
            }
            pub fn select(nested_selections: Vec<change_request::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<change_request::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod component_name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "componentName";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetComponentName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ComponentName(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ComponentName(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::ComponentName(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            ComponentName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ComponentName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ComponentName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod component_version {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "componentVersion";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetComponentVersion(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ComponentVersion(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ComponentVersion(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::ComponentVersion(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            ComponentVersion,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ComponentVersion(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ComponentVersion(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod component_revision {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "componentRevision";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetComponentRevision(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ComponentRevision(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ComponentRevision(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::ComponentRevision(_prisma::read_filters::StringNullableFilter::Equals(
                value,
            ))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            ComponentRevision,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ComponentRevision(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ComponentRevision(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod gate_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "gateId";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetGateId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::GateId(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::GateId(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::GateId(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            GateId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GateId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GateId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod change_request_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "changeRequestId";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetChangeRequestId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ChangeRequestId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ChangeRequestId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ChangeRequestId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            ChangeRequestId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ChangeRequestId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ChangeRequestId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub fn create(
        change_request: super::change_request::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (super::change_request::UniqueWhereParam, Vec<SetParam>) {
        (change_request, _params)
    }
    pub fn create_unchecked(
        change_request_id: String,
        _params: Vec<SetParam>,
    ) -> (String, Vec<SetParam>) {
        (change_request_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_build_job { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: build_job :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: build_job :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: build_job :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: build_job :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: build_job :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: build_job :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , component , change_request , component_name , component_version , component_revision , gate_id , change_request_id } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: build_job :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: build_job :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: build_job :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: build_job :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: build_job :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: build_job :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "component" , "change_request" , "componentName" , "componentVersion" , "componentRevision" , "gateId" , "changeRequestId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: build_job :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; component : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < component :: Data > } ; (@ field_type ; component) => { Option < crate :: prisma :: component :: Data > } ; (@ field_type ; change_request : $ selection_mode : ident { $ ($ selections : tt) + }) => { change_request :: Data } ; (@ field_type ; change_request) => { crate :: prisma :: change_request :: Data } ; (@ field_type ; component_name) => { Option < String > } ; (@ field_type ; component_version) => { Option < String > } ; (@ field_type ; component_revision) => { Option < String > } ; (@ field_type ; gate_id) => { Option < String > } ; (@ field_type ; change_request_id) => { String } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "BuildJob" , available relations are "id, component, change_request, component_name, component_version, component_revision, gate_id, change_request_id")) } ; (@ field_module ; component : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: component :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; change_request : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: change_request :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: build_job :: SelectParam > :: into (crate :: prisma :: build_job :: id :: Select) } ; (@ selection_field_to_selection_param ; component $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: build_job :: SelectParam > :: into (crate :: prisma :: build_job :: component :: Select :: $ selection_mode (crate :: prisma :: component :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; component $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: build_job :: SelectParam > :: into (crate :: prisma :: build_job :: component :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; change_request $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: build_job :: SelectParam > :: into (crate :: prisma :: build_job :: change_request :: Select :: $ selection_mode (crate :: prisma :: change_request :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; change_request $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: build_job :: SelectParam > :: into (crate :: prisma :: build_job :: change_request :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; component_name) => { Into :: < crate :: prisma :: build_job :: SelectParam > :: into (crate :: prisma :: build_job :: component_name :: Select) } ; (@ selection_field_to_selection_param ; component_version) => { Into :: < crate :: prisma :: build_job :: SelectParam > :: into (crate :: prisma :: build_job :: component_version :: Select) } ; (@ selection_field_to_selection_param ; component_revision) => { Into :: < crate :: prisma :: build_job :: SelectParam > :: into (crate :: prisma :: build_job :: component_revision :: Select) } ; (@ selection_field_to_selection_param ; gate_id) => { Into :: < crate :: prisma :: build_job :: SelectParam > :: into (crate :: prisma :: build_job :: gate_id :: Select) } ; (@ selection_field_to_selection_param ; change_request_id) => { Into :: < crate :: prisma :: build_job :: SelectParam > :: into (crate :: prisma :: build_job :: change_request_id :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: build_job :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; component) => { "component" } ; (@ field_serde_name ; change_request) => { "change_request" } ; (@ field_serde_name ; component_name) => { "componentName" } ; (@ field_serde_name ; component_version) => { "componentVersion" } ; (@ field_serde_name ; component_revision) => { "componentRevision" } ; (@ field_serde_name ; gate_id) => { "gateId" } ; (@ field_serde_name ; change_request_id) => { "changeRequestId" } ; }
    pub use _select_build_job as select;
    pub enum SelectParam {
        Id(id::Select),
        Component(component::Select),
        ChangeRequest(change_request::Select),
        ComponentName(component_name::Select),
        ComponentVersion(component_version::Select),
        ComponentRevision(component_revision::Select),
        GateId(gate_id::Select),
        ChangeRequestId(change_request_id::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Component(data) => data.to_selection(),
                Self::ChangeRequest(data) => data.to_selection(),
                Self::ComponentName(data) => data.to_selection(),
                Self::ComponentVersion(data) => data.to_selection(),
                Self::ComponentRevision(data) => data.to_selection(),
                Self::GateId(data) => data.to_selection(),
                Self::ChangeRequestId(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_build_job { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: build_job :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: build_job :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: build_job :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: build_job :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: build_job :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: build_job :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: build_job :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: build_job :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { component , change_request } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub component_name : Option < String > , pub component_version : Option < String > , pub component_revision : Option < String > , pub gate_id : Option < String > , pub change_request_id : String , $ (pub $ field : crate :: prisma :: build_job :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (component_name) , stringify ! (component_version) , stringify ! (component_revision) , stringify ! (gate_id) , stringify ! (change_request_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: build_job :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: build_job :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: build_job :: component_name :: NAME , & self . component_name) ? ; state . serialize_field (crate :: prisma :: build_job :: component_version :: NAME , & self . component_version) ? ; state . serialize_field (crate :: prisma :: build_job :: component_revision :: NAME , & self . component_revision) ? ; state . serialize_field (crate :: prisma :: build_job :: gate_id :: NAME , & self . gate_id) ? ; state . serialize_field (crate :: prisma :: build_job :: change_request_id :: NAME , & self . change_request_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , component_name , component_version , component_revision , gate_id , change_request_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: build_job :: $ field :: NAME) , + , crate :: prisma :: build_job :: id :: NAME , crate :: prisma :: build_job :: component_name :: NAME , crate :: prisma :: build_job :: component_version :: NAME , crate :: prisma :: build_job :: component_revision :: NAME , crate :: prisma :: build_job :: gate_id :: NAME , crate :: prisma :: build_job :: change_request_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: build_job :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: build_job :: id :: NAME => Ok (Field :: id) , crate :: prisma :: build_job :: component_name :: NAME => Ok (Field :: component_name) , crate :: prisma :: build_job :: component_version :: NAME => Ok (Field :: component_version) , crate :: prisma :: build_job :: component_revision :: NAME => Ok (Field :: component_revision) , crate :: prisma :: build_job :: gate_id :: NAME => Ok (Field :: gate_id) , crate :: prisma :: build_job :: change_request_id :: NAME => Ok (Field :: change_request_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut component_name = None ; let mut component_version = None ; let mut component_revision = None ; let mut gate_id = None ; let mut change_request_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: build_job :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: component_name => { if component_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: build_job :: component_name :: NAME)) ; } component_name = Some (map . next_value () ?) ; } Field :: component_version => { if component_version . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: build_job :: component_version :: NAME)) ; } component_version = Some (map . next_value () ?) ; } Field :: component_revision => { if component_revision . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: build_job :: component_revision :: NAME)) ; } component_revision = Some (map . next_value () ?) ; } Field :: gate_id => { if gate_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: build_job :: gate_id :: NAME)) ; } gate_id = Some (map . next_value () ?) ; } Field :: change_request_id => { if change_request_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: build_job :: change_request_id :: NAME)) ; } change_request_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: build_job :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: build_job :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: build_job :: id :: NAME)) ? ; let component_name = component_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: build_job :: component_name :: NAME)) ? ; let component_version = component_version . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: build_job :: component_version :: NAME)) ? ; let component_revision = component_revision . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: build_job :: component_revision :: NAME)) ? ; let gate_id = gate_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: build_job :: gate_id :: NAME)) ? ; let change_request_id = change_request_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: build_job :: change_request_id :: NAME)) ? ; Ok (Data { id , component_name , component_version , component_revision , gate_id , change_request_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "component" , "change_request" , "componentName" , "componentVersion" , "componentRevision" , "gateId" , "changeRequestId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: build_job :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; component : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < component :: Data > } ; (@ field_type ; component) => { Option < crate :: prisma :: component :: Data > } ; (@ field_type ; change_request : $ selection_mode : ident { $ ($ selections : tt) + }) => { change_request :: Data } ; (@ field_type ; change_request) => { crate :: prisma :: change_request :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "BuildJob" , available relations are "component, change_request")) } ; (@ field_module ; component : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: component :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; change_request : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: change_request :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; component $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: build_job :: IncludeParam > :: into (crate :: prisma :: build_job :: component :: Include :: $ selection_mode (crate :: prisma :: component :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; component $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: build_job :: IncludeParam > :: into (crate :: prisma :: build_job :: component :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; change_request $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: build_job :: IncludeParam > :: into (crate :: prisma :: build_job :: change_request :: Include :: $ selection_mode (crate :: prisma :: change_request :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; change_request $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: build_job :: IncludeParam > :: into (crate :: prisma :: build_job :: change_request :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: build_job :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; component) => { "component" } ; (@ field_serde_name ; change_request) => { "change_request" } ; (@ field_serde_name ; component_name) => { "componentName" } ; (@ field_serde_name ; component_version) => { "componentVersion" } ; (@ field_serde_name ; component_revision) => { "componentRevision" } ; (@ field_serde_name ; gate_id) => { "gateId" } ; (@ field_serde_name ; change_request_id) => { "changeRequestId" } ; }
    pub use _include_build_job as include;
    pub enum IncludeParam {
        Id(id::Include),
        Component(component::Include),
        ChangeRequest(change_request::Include),
        ComponentName(component_name::Include),
        ComponentVersion(component_version::Include),
        ComponentRevision(component_revision::Include),
        GateId(gate_id::Include),
        ChangeRequestId(change_request_id::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Component(data) => data.to_selection(),
                Self::ChangeRequest(data) => data.to_selection(),
                Self::ComponentName(data) => data.to_selection(),
                Self::ComponentVersion(data) => data.to_selection(),
                Self::ComponentRevision(data) => data.to_selection(),
                Self::GateId(data) => data.to_selection(),
                Self::ChangeRequestId(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_build_job { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: build_job struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "componentName")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub component_name : Option < String > , # [serde (rename = "componentVersion")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub component_version : Option < String > , # [serde (rename = "componentRevision")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub component_revision : Option < String > , # [serde (rename = "gateId")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub gate_id : Option < String > , # [serde (rename = "changeRequestId")] pub change_request_id : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_build_job as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(
            rename = "component",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub component: Option<Option<Box<super::component::Data>>>,
        #[serde(rename = "change_request")]
        pub change_request: Option<Box<super::change_request::Data>>,
        #[serde(rename = "componentName")]
        pub component_name: Option<String>,
        #[serde(rename = "componentVersion")]
        pub component_version: Option<String>,
        #[serde(rename = "componentRevision")]
        pub component_revision: Option<String>,
        #[serde(rename = "gateId")]
        pub gate_id: Option<String>,
        #[serde(rename = "changeRequestId")]
        pub change_request_id: String,
    }
    impl Data {
        pub fn component(
            &self,
        ) -> Result<Option<&super::component::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.component
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(component),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn change_request(
            &self,
        ) -> Result<&super::change_request::Data, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.change_request
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(change_request),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Component(super::component::UniqueArgs),
        ChangeRequest(super::change_request::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Component(args) => {
                    let mut selections = < super :: component :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(component::NAME, None, [], selections)
                }
                Self::ChangeRequest(args) => {
                    let mut selections = < super :: change_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(change_request::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        ConnectComponent(super::component::UniqueWhereParam),
        DisconnectComponent,
        ConnectChangeRequest(super::change_request::UniqueWhereParam),
        SetComponentName(Option<String>),
        SetComponentVersion(Option<String>),
        SetComponentRevision(Option<String>),
        SetGateId(Option<String>),
        SetChangeRequestId(String),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectComponent(where_param) => (
                    component::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::component::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectComponent => (
                    component::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::ConnectChangeRequest(where_param) => (
                    change_request::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::change_request::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetComponentName(value) => (
                    component_name::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetComponentVersion(value) => (
                    component_version::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetComponentRevision(value) => (
                    component_revision::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetGateId(value) => (
                    gate_id::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetChangeRequestId(value) => (
                    change_request_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(String),
        ComponentName(Option<String>),
        ComponentVersion(Option<String>),
        ComponentRevision(Option<String>),
        GateId(Option<String>),
        ChangeRequestId(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::ComponentName(value) => Self::SetComponentName(value),
                UncheckedSetParam::ComponentVersion(value) => Self::SetComponentVersion(value),
                UncheckedSetParam::ComponentRevision(value) => Self::SetComponentRevision(value),
                UncheckedSetParam::GateId(value) => Self::SetGateId(value),
                UncheckedSetParam::ChangeRequestId(value) => Self::SetChangeRequestId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        ComponentName(::prisma_client_rust::Direction),
        ComponentVersion(::prisma_client_rust::Direction),
        ComponentRevision(::prisma_client_rust::Direction),
        GateId(::prisma_client_rust::Direction),
        ChangeRequestId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ComponentName(direction) => (
                    component_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ComponentVersion(direction) => (
                    component_version::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ComponentRevision(direction) => (
                    component_revision::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::GateId(direction) => (
                    gate_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ChangeRequestId(direction) => (
                    change_request_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        ComponentIsNull,
        ComponentIs(Vec<super::component::WhereParam>),
        ComponentIsNot(Vec<super::component::WhereParam>),
        ChangeRequestIs(Vec<super::change_request::WhereParam>),
        ChangeRequestIsNot(Vec<super::change_request::WhereParam>),
        ComponentName(_prisma::read_filters::StringNullableFilter),
        ComponentVersion(_prisma::read_filters::StringNullableFilter),
        ComponentRevision(_prisma::read_filters::StringNullableFilter),
        GateId(_prisma::read_filters::StringNullableFilter),
        ChangeRequestId(_prisma::read_filters::StringFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::ComponentIsNull => (
                    component::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::ComponentIs(where_params) => (
                    component::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ComponentIsNot(where_params) => (
                    component::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ChangeRequestIs(where_params) => (
                    change_request::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ChangeRequestIsNot(where_params) => (
                    change_request::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ComponentName(value) => (component_name::NAME, value.into()),
                Self::ComponentVersion(value) => (component_version::NAME, value.into()),
                Self::ComponentRevision(value) => (component_revision::NAME, value.into()),
                Self::GateId(value) => (gate_id::NAME, value.into()),
                Self::ChangeRequestId(value) => (change_request_id::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(component_name::NAME),
                ::prisma_client_rust::sel(component_version::NAME),
                ::prisma_client_rust::sel(component_revision::NAME),
                ::prisma_client_rust::sel(gate_id::NAME),
                ::prisma_client_rust::sel(change_request_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            change_request: super::change_request::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([change_request::connect(change_request)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            change_request_id: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([change_request_id::set(change_request_id)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(change_request_id, mut _params)| {
                    _params.extend([change_request_id::set(change_request_id)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (change_request, mut _params): (super::change_request::UniqueWhereParam, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([change_request::connect(change_request)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod _prisma {
    pub struct PrismaClientBuilder {
        url: Option<String>,
        action_notifier: ::prisma_client_rust::ActionNotifier,
    }
    impl PrismaClientBuilder {
        fn new() -> Self {
            Self {
                url: None,
                action_notifier: ::prisma_client_rust::ActionNotifier::new(),
            }
        }
        pub fn with_url(mut self, url: String) -> Self {
            self.url = Some(url);
            self
        }
        pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
            let internals = ::prisma_client_rust::PrismaClientInternals::new(
                self.url,
                self.action_notifier,
                super::DATAMODEL_STR,
            )
            .await?;
            Ok(PrismaClient(internals))
        }
    }
    pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
    impl ::std::fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub fn _builder() -> PrismaClientBuilder {
            PrismaClientBuilder::new()
        }
        pub fn _query_raw<T: ::prisma_client_rust::Data>(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::QueryRaw<T> {
            ::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub fn _execute_raw(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::ExecuteRaw {
            ::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub async fn _batch<
            'batch,
            T: ::prisma_client_rust::BatchContainer<'batch, Marker>,
            Marker,
        >(
            &self,
            queries: T,
        ) -> ::prisma_client_rust::Result<
            <T as ::prisma_client_rust::BatchContainer<'batch, Marker>>::ReturnType,
        > {
            ::prisma_client_rust::batch(queries, &self.0).await
        }
        pub fn _transaction(&self) -> ::prisma_client_rust::TransactionBuilder<Self> {
            ::prisma_client_rust::TransactionBuilder::_new(self, &self.0)
        }
        pub fn domain(&self) -> super::domain::Actions {
            super::domain::Actions { client: &self.0 }
        }
        pub fn actor(&self) -> super::actor::Actions {
            super::actor::Actions { client: &self.0 }
        }
        pub fn key(&self) -> super::key::Actions {
            super::key::Actions { client: &self.0 }
        }
        pub fn publisher(&self) -> super::publisher::Actions {
            super::publisher::Actions { client: &self.0 }
        }
        pub fn package_repository(&self) -> super::package_repository::Actions {
            super::package_repository::Actions { client: &self.0 }
        }
        pub fn gate(&self) -> super::gate::Actions {
            super::gate::Actions { client: &self.0 }
        }
        pub fn component(&self) -> super::component::Actions {
            super::component::Actions { client: &self.0 }
        }
        pub fn component_change(&self) -> super::component_change::Actions {
            super::component_change::Actions { client: &self.0 }
        }
        pub fn change_request(&self) -> super::change_request::Actions {
            super::change_request::Actions { client: &self.0 }
        }
        pub fn build_job(&self) -> super::build_job::Actions {
            super::build_job::Actions { client: &self.0 }
        }
    }
    impl ::prisma_client_rust::PrismaClient for PrismaClient {
        fn internals(&self) -> &::prisma_client_rust::PrismaClientInternals {
            &self.0
        }
        fn internals_mut(&mut self) -> &mut ::prisma_client_rust::PrismaClientInternals {
            &mut self.0
        }
        fn with_tx_id(&self, tx_id: Option<::prisma_client_rust::query_core::TxId>) -> Self {
            Self(self.0.with_tx_id(tx_id))
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum ActorScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "displayName")]
        DisplayName,
        #[serde(rename = "handle")]
        Handle,
        #[serde(rename = "domainId")]
        DomainId,
    }
    impl ToString for ActorScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::DisplayName => "displayName".to_string(),
                Self::Handle => "handle".to_string(),
                Self::DomainId => "domainId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum BuildJobScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "componentName")]
        ComponentName,
        #[serde(rename = "componentVersion")]
        ComponentVersion,
        #[serde(rename = "componentRevision")]
        ComponentRevision,
        #[serde(rename = "gateId")]
        GateId,
        #[serde(rename = "changeRequestId")]
        ChangeRequestId,
    }
    impl ToString for BuildJobScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::ComponentName => "componentName".to_string(),
                Self::ComponentVersion => "componentVersion".to_string(),
                Self::ComponentRevision => "componentRevision".to_string(),
                Self::GateId => "gateId".to_string(),
                Self::ChangeRequestId => "changeRequestId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum ChangeRequestScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "processing")]
        Processing,
        #[serde(rename = "waitForRequestId")]
        WaitForRequestId,
        #[serde(rename = "build_order")]
        BuildOrder,
        #[serde(rename = "external_reference")]
        ExternalReference,
    }
    impl ToString for ChangeRequestScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Processing => "processing".to_string(),
                Self::WaitForRequestId => "waitForRequestId".to_string(),
                Self::BuildOrder => "build_order".to_string(),
                Self::ExternalReference => "external_reference".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum ComponentChangeScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "kind")]
        Kind,
        #[serde(rename = "diff")]
        Diff,
        #[serde(rename = "recipe")]
        Recipe,
        #[serde(rename = "version")]
        Version,
        #[serde(rename = "revision")]
        Revision,
        #[serde(rename = "patches")]
        Patches,
        #[serde(rename = "scripts")]
        Scripts,
        #[serde(rename = "archives")]
        Archives,
        #[serde(rename = "componentName")]
        ComponentName,
        #[serde(rename = "componentVersion")]
        ComponentVersion,
        #[serde(rename = "componentRevision")]
        ComponentRevision,
        #[serde(rename = "gateId")]
        GateId,
        #[serde(rename = "changeRequestId")]
        ChangeRequestId,
    }
    impl ToString for ComponentChangeScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Kind => "kind".to_string(),
                Self::Diff => "diff".to_string(),
                Self::Recipe => "recipe".to_string(),
                Self::Version => "version".to_string(),
                Self::Revision => "revision".to_string(),
                Self::Patches => "patches".to_string(),
                Self::Scripts => "scripts".to_string(),
                Self::Archives => "archives".to_string(),
                Self::ComponentName => "componentName".to_string(),
                Self::ComponentVersion => "componentVersion".to_string(),
                Self::ComponentRevision => "componentRevision".to_string(),
                Self::GateId => "gateId".to_string(),
                Self::ChangeRequestId => "changeRequestId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum ComponentScalarFieldEnum {
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "version")]
        Version,
        #[serde(rename = "revision")]
        Revision,
        #[serde(rename = "anitya_id")]
        AnityaId,
        #[serde(rename = "repology_id")]
        RepologyId,
        #[serde(rename = "project_url")]
        ProjectUrl,
        #[serde(rename = "recipe")]
        Recipe,
        #[serde(rename = "patches")]
        Patches,
        #[serde(rename = "scripts")]
        Scripts,
        #[serde(rename = "archives")]
        Archives,
        #[serde(rename = "packages")]
        Packages,
        #[serde(rename = "gateId")]
        GateId,
    }
    impl ToString for ComponentScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Name => "name".to_string(),
                Self::Version => "version".to_string(),
                Self::Revision => "revision".to_string(),
                Self::AnityaId => "anitya_id".to_string(),
                Self::RepologyId => "repology_id".to_string(),
                Self::ProjectUrl => "project_url".to_string(),
                Self::Recipe => "recipe".to_string(),
                Self::Patches => "patches".to_string(),
                Self::Scripts => "scripts".to_string(),
                Self::Archives => "archives".to_string(),
                Self::Packages => "packages".to_string(),
                Self::GateId => "gateId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum DomainScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "dnsName")]
        DnsName,
        #[serde(rename = "authconf")]
        Authconf,
    }
    impl ToString for DomainScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::DnsName => "dnsName".to_string(),
                Self::Authconf => "authconf".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum GateScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "version")]
        Version,
        #[serde(rename = "branch")]
        Branch,
        #[serde(rename = "transforms")]
        Transforms,
        #[serde(rename = "publisherId")]
        PublisherId,
    }
    impl ToString for GateScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Name => "name".to_string(),
                Self::Version => "version".to_string(),
                Self::Branch => "branch".to_string(),
                Self::Transforms => "transforms".to_string(),
                Self::PublisherId => "publisherId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum JsonNullValueFilter {
        #[serde(rename = "DbNull")]
        DbNull,
        #[serde(rename = "JsonNull")]
        JsonNull,
        #[serde(rename = "AnyNull")]
        AnyNull,
    }
    impl ToString for JsonNullValueFilter {
        fn to_string(&self) -> String {
            match self {
                Self::DbNull => "DbNull".to_string(),
                Self::JsonNull => "JsonNull".to_string(),
                Self::AnyNull => "AnyNull".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum JsonNullValueInput {
        #[serde(rename = "JsonNull")]
        JsonNull,
    }
    impl ToString for JsonNullValueInput {
        fn to_string(&self) -> String {
            match self {
                Self::JsonNull => "JsonNull".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum KeyScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "actorId")]
        ActorId,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "private_key")]
        PrivateKey,
        #[serde(rename = "public_key")]
        PublicKey,
        #[serde(rename = "key_type")]
        KeyType,
    }
    impl ToString for KeyScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::ActorId => "actorId".to_string(),
                Self::Name => "name".to_string(),
                Self::PrivateKey => "private_key".to_string(),
                Self::PublicKey => "public_key".to_string(),
                Self::KeyType => "key_type".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum PackageRepositoryScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "publisherId")]
        PublisherId,
    }
    impl ToString for PackageRepositoryScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Name => "name".to_string(),
                Self::PublisherId => "publisherId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum PublisherScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "name")]
        Name,
    }
    impl ToString for PublisherScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Name => "name".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum QueryMode {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "insensitive")]
        Insensitive,
    }
    impl ToString for QueryMode {
        fn to_string(&self) -> String {
            match self {
                Self::Default => "default".to_string(),
                Self::Insensitive => "insensitive".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum TransactionIsolationLevel {
        #[serde(rename = "ReadUncommitted")]
        ReadUncommitted,
        #[serde(rename = "ReadCommitted")]
        ReadCommitted,
        #[serde(rename = "RepeatableRead")]
        RepeatableRead,
        #[serde(rename = "Serializable")]
        Serializable,
    }
    impl ToString for TransactionIsolationLevel {
        fn to_string(&self) -> String {
            match self {
                Self::ReadUncommitted => "ReadUncommitted".to_string(),
                Self::ReadCommitted => "ReadCommitted".to_string(),
                Self::RepeatableRead => "RepeatableRead".to_string(),
                Self::Serializable => "Serializable".to_string(),
            }
        }
    }
    impl ::prisma_client_rust::TransactionIsolationLevel for TransactionIsolationLevel {}
    pub mod read_filters {
        #[derive(Clone)]
        pub enum StringListFilter {
            Equals(Vec<String>),
            Has(Option<String>),
            HasEvery(Vec<String>),
            HasSome(Vec<String>),
            IsEmpty(bool),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringListFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Has(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "has".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                    Self::HasEvery(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "hasEvery".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::HasSome(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "hasSome".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::IsEmpty(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "isEmpty".to_string(),
                            ::prisma_client_rust::PrismaValue::Boolean(value),
                        )])
                    }
                }
            }
        }
        #[derive(Clone)]
        pub enum StringFilter {
            Equals(String),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Mode(super::super::QueryMode),
            Not(String),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Mode(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "mode".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum StringNullableFilter {
            Equals(Option<String>),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Mode(super::super::QueryMode),
            Not(Option<String>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringNullableFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Mode(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "mode".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum BoolFilter {
            Equals(bool),
            Not(bool),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for BoolFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Boolean(value),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum JsonFilter {
            Equals(::prisma_client_rust::serde_json::Value),
            Path(Vec<String>),
            StringContains(String),
            StringStartsWith(String),
            StringEndsWith(String),
            ArrayContains(Option<::prisma_client_rust::serde_json::Value>),
            ArrayStartsWith(Option<::prisma_client_rust::serde_json::Value>),
            ArrayEndsWith(Option<::prisma_client_rust::serde_json::Value>),
            Lt(::prisma_client_rust::serde_json::Value),
            Lte(::prisma_client_rust::serde_json::Value),
            Gt(::prisma_client_rust::serde_json::Value),
            Gte(::prisma_client_rust::serde_json::Value),
            Not(::prisma_client_rust::serde_json::Value),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for JsonFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Json(
                                ::prisma_client_rust::serde_json::to_string(&value).unwrap(),
                            ),
                        )])
                    }
                    Self::Path(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "path".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::StringContains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "string_contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StringStartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "string_starts_with".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StringEndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "string_ends_with".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::ArrayContains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "array_contains".to_string(),
                            value
                                .map(|value| {
                                    ::prisma_client_rust::PrismaValue::Json(
                                        ::prisma_client_rust::serde_json::to_string(&value)
                                            .unwrap(),
                                    )
                                })
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    Self::ArrayStartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "array_starts_with".to_string(),
                            value
                                .map(|value| {
                                    ::prisma_client_rust::PrismaValue::Json(
                                        ::prisma_client_rust::serde_json::to_string(&value)
                                            .unwrap(),
                                    )
                                })
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    Self::ArrayEndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "array_ends_with".to_string(),
                            value
                                .map(|value| {
                                    ::prisma_client_rust::PrismaValue::Json(
                                        ::prisma_client_rust::serde_json::to_string(&value)
                                            .unwrap(),
                                    )
                                })
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Json(
                            ::prisma_client_rust::serde_json::to_string(&value).unwrap(),
                        ),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Json(
                            ::prisma_client_rust::serde_json::to_string(&value).unwrap(),
                        ),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Json(
                            ::prisma_client_rust::serde_json::to_string(&value).unwrap(),
                        ),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Json(
                            ::prisma_client_rust::serde_json::to_string(&value).unwrap(),
                        ),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Json(
                            ::prisma_client_rust::serde_json::to_string(&value).unwrap(),
                        ),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum KeyTypeFilter {
            Equals(super::super::KeyType),
            InVec(Vec<super::super::KeyType>),
            NotInVec(Vec<super::super::KeyType>),
            Not(super::super::KeyType),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for KeyTypeFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum ComponentChangeKindFilter {
            Equals(super::super::ComponentChangeKind),
            InVec(Vec<super::super::ComponentChangeKind>),
            NotInVec(Vec<super::super::ComponentChangeKind>),
            Not(super::super::ComponentChangeKind),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for ComponentChangeKindFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                }
            }
        }
    }
}
pub use _prisma::*;
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum KeyType {
    #[serde(rename = "Ed25519")]
    Ed25519,
}
impl ToString for KeyType {
    fn to_string(&self) -> String {
        match self {
            Self::Ed25519 => "Ed25519".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum ComponentChangeKind {
    #[serde(rename = "Added")]
    Added,
    #[serde(rename = "Updated")]
    Updated,
    #[serde(rename = "Removed")]
    Removed,
}
impl ToString for ComponentChangeKind {
    fn to_string(&self) -> String {
        match self {
            Self::Added => "Added".to_string(),
            Self::Updated => "Updated".to_string(),
            Self::Removed => "Removed".to_string(),
        }
    }
}
